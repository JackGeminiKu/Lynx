-- Hunter
Hunter = {}
function Hunter:GetAmmoName()
    local level = Player:Level()
    if level >= 55 then
        return "Wicked Arrow"
    elseif level >= 40 then
        return "Jagged Arrow"
    elseif level >= 25 then
        return "Razor Arrow"
    elseif level >= 15 then
        return "Sharp Arrow"
    else
        return "Rough Arrow"
    end
end

function Hunter:GetAmmoMaxCount()
    return 3000
end

function Hunter:BuyDrinks()
    local drinksToHave = 140
    Log.WriteLine('Buying Drinks')
    local drinkSlot = GetVendorSlot(Drinks[2])
    if drinkSlot ~= -1 then
        local drinkCount = Bag.GetItemCount(Drinks[2])
        if drinkCount >= drinksToHave then
            return
        end

        local needToBuy = drinksToHave - drinkCount;
        Log.WriteLine('Buying ' .. needToBuy .. ' ' .. Drinks[2]);
        local div = needToBuy / 5
        for i = 1, div do
            Player.Buy(drinkSlot);
        end
        Sleep(1) -- ammo takes a ton of time to appear	
    end
end

function Hunter:BuyAmmo()
    if Player:IsHunter() == false then
        return
    end

    local vendorSlot = GetVendorSlot(self:GetAmmoName())
    if vendorSlot == -1 then
        return
    end

    local ammoCount = Bag.GetItemCount(self:GetAmmoName())
    local needToBuy = self:GetAmmoMaxCount() - ammoCount;
    if needToBuy < 200 then
        return
    end

    Log.WriteLine('Buying ' .. needToBuy .. ' ' .. self:GetAmmoName());
    local div = needToBuy / 200
    for i = 1, div do
        Player.Buy(vendorSlot);
    end

    Sleep(1) -- ammo takes a ton of time to appear
end

-- CHECK FOR --REMOVE for other zones
--------------------FILE STUFF--------------------
MAIL_ENABLED = false -- NO MAIL!

-- Keep drink 2 for hunter buy!
Drinks = {"Conjured Fresh Water", "Conjured Sparkling Water", "Sweet Nectar", "Ice Cold Milk", "Melon Juice"}
Foods = {"Conjured Muffin", "Conjured Sourdough", "Wild Hog Shank", "Mutton Chop", "Cured Ham Steak"}

--------------------CLASS SPECIFIC--------------------
PetFoods = {"Haunch of Meat", "Big Bear Meat", "Turtle Meat", "Mutton Chop", "Wild Hog Shank", "Red Wolf Meat"}
PET_MEND_HP = 25 -- Heal pet at this HP
PetMendHP = PET_MEND_HP
HunterBuff = "Aspect of the Hawk"
AGGRO_WITH_PET = false -- Hunter tags and pet only goes in if in melee range

PREFER_MAGE_ARMOR = false
WAND_BELOW = 1 -- wand below X%
CS_DELAY = math.random(0.9, 1.2)

--------------------GENERAL--------------------
MOUNT_NAME = "Brown Horse Bridle"

AvoidNPCs = {"Scorched Guardian", "Teremus the Devourer", "Servant of Grol", "Boss Tho'gun", "Anathemus", "Dustbelcher Mystic", "Dustbelcher Shaman", "Dustbelcher Wyrmhunter", "Dustbelcher Mauler"}
ToMail = {"Mageweave Cloth", "Runecloth", "Silk Cloth", "Wool Cloth", "Rugged Leather", "Thick Leather", "Felcloth", "Mageweave Cloth", "Demonic Rune"} -- Can leave empty if mailing
ForcedToSell = {"Citrine"}
OpenInBags = {"Thick-shelled Clam"}
ToKeep = {"Brown Horse Bridle", "Skinning Knife", "Strong Fishing Pole", "Fishing Pole", "Rune of Teleportation", "Rune of Portals"}

Waypoints = { --
    [1] = {3900.4057617188, -878.15447998047, 277.8918762207},
    [2] = {3897.9526367188, -873.376953125, 278.96032714844},
    [3] = {3894.9252929688, -868.85729980469, 280.11065673828},
    [4] = {3891.5666503906, -864.20245361328, 281.08041381836},
    [5] = {3888.1574707031, -859.88012695313, 281.80163574219},
    [6] = {3884.4685058594, -855.78179931641, 282.61917114258},
    [7] = {3880.0959472656, -851.98004150391, 283.76119995117},
    [8] = {3875.3833007813, -848.68823242188, 284.81030273438},
    [9] = {3870.7502441406, -845.54388427734, 285.98251342773},
    [10] = {3866.1181640625, -842.65393066406, 287.04534912109},
    [11] = {3861.3842773438, -839.65942382813, 287.46258544922},
    [12] = {3856.9855957031, -836.68267822266, 287.53442382813},
    [13] = {3852.5476074219, -833.67059326172, 288.20452880859},
    [14] = {3847.5446777344, -830.27520751953, 288.79516601563},
    [15] = {3843.0012207031, -827.81237792969, 289.44387817383},
    [16] = {3838.0163574219, -825.16949462891, 290.74725341797},
    [17] = {3833.5275878906, -822.12298583984, 292.15951538086},
    [18] = {3828.6774902344, -818.927734375, 293.4382019043},
    [19] = {3823.3073730469, -816.30944824219, 295.14202880859},
    [20] = {3819.1806640625, -812.81884765625, 296.80813598633},
    [21] = {3814.3149414063, -810.26977539063, 298.83087158203},
    [22] = {3811.3552246094, -805.70239257813, 300.67501831055},
    [23] = {3806.4106445313, -803.75592041016, 303.22235107422},
    [24] = {3801.2937011719, -806.02081298828, 304.76080322266},
    [25] = {3796.4243164063, -809.18969726563, 307.87817382813},
    [26] = {3791.8322753906, -812.12579345703, 307.72457885742},
    [27] = {3787.162109375, -815.0048828125, 308.17434692383},
    [28] = {3783.3525390625, -818.66851806641, 308.97760009766},
    [29] = {3778.5771484375, -822.55590820313, 309.50183105469},
    [30] = {3774.0817871094, -825.40185546875, 310.00628662109},
    [31] = {3768.4790039063, -827.31469726563, 310.75393676758},
    [32] = {3762.9462890625, -829.06396484375, 311.15771484375},
    [33] = {3757.3303222656, -830.20581054688, 311.87380981445},
    [34] = {3752.2668457031, -832.27734375, 311.76300048828},
    [35] = {3746.9670410156, -833.1923828125, 312.26992797852},
    [36] = {3743.9216308594, -828.61437988281, 315.02047729492},
    [37] = {3749.099609375, -827.39074707031, 314.14202880859},
    [38] = {3754.1716308594, -825.17260742188, 313.64422607422},
    [39] = {3759.0671386719, -822.96826171875, 313.05612182617},
    [40] = {3764.2993164063, -820.92504882813, 313.44543457031},
    [41] = {3769.4560546875, -819.18225097656, 313.29846191406},
    [42] = {3774.8012695313, -817.23876953125, 312.47103881836},
    [43] = {3779.9582519531, -815.91015625, 310.8258972168},
    [44] = {3785.1811523438, -814.62042236328, 309.26327514648},
    [45] = {3790.3676757813, -812.40753173828, 308.00384521484},
    [46] = {3795.0598144531, -809.52111816406, 308.0085144043},
    [47] = {3799.669921875, -806.25042724609, 305.71697998047},
    [48] = {3804.1376953125, -803.02178955078, 304.40341186523},
    [49] = {3808.4978027344, -799.69201660156, 304.06625366211},
    [50] = {3812.7028808594, -795.91412353516, 304.65972900391},
    [51] = {3816.6657714844, -791.99914550781, 305.76983642578},
    [52] = {3820.5927734375, -788.40014648438, 306.98291015625},
    [53] = {3824.8220214844, -784.99566650391, 308.29040527344},
    [54] = {3829.5385742188, -781.57250976563, 309.80212402344},
    [55] = {3834.3562011719, -778.94287109375, 310.53704833984},
    [56] = {3839.3132324219, -776.86010742188, 310.67474365234},
    [57] = {3844.7099609375, -775.33392333984, 310.54931640625},
    [58] = {3850.2839355469, -773.89611816406, 311.38360595703},
    [59] = {3855.6281738281, -772.86187744141, 312.53564453125},
    [60] = {3861.3935546875, -772.01428222656, 313.13220214844},
    [61] = {3866.9372558594, -770.95709228516, 312.79870605469},
    [62] = {3872.6784667969, -770.08135986328, 312.07363891602},
    [63] = {3878.0864257813, -769.33221435547, 311.6682434082},
    [64] = {3883.1596679688, -770.35626220703, 311.67404174805},
    [65] = {3889.0517578125, -770.09063720703, 312.39990234375},
    [66] = {3891.3852539063, -764.31420898438, 312.69204711914},
    [67] = {3885.80078125, -764.44207763672, 311.88873291016},
    [68] = {3880.0246582031, -764.87744140625, 311.80612182617},
    [69] = {3874.4929199219, -765.29443359375, 312.07733154297},
    [70] = {3868.9350585938, -765.71337890625, 312.45016479492},
    [71] = {3863.6125488281, -766.11456298828, 312.69836425781},
    [72] = {3857.6342773438, -766.62951660156, 312.55944824219},
    [73] = {3852.1701660156, -768.20294189453, 312.18975830078},
    [74] = {3846.9643554688, -769.33270263672, 312.08215332031},
    [75] = {3841.5947265625, -770.16497802734, 312.29699707031},
    [76] = {3836.0871582031, -771.02044677734, 312.17437744141},
    [77] = {3830.9362792969, -771.88110351563, 312.02697753906},
    [78] = {3825.5310058594, -772.34576416016, 312.32336425781},
    [79] = {3820.4184570313, -770.14630126953, 313.66595458984},
    [80] = {3819.5561523438, -764.84234619141, 315.60629272461},
    [81] = {3819.6013183594, -759.50531005859, 317.43103027344},
    [82] = {3820.232421875, -753.68023681641, 319.28973388672},
    [83] = {3822.15234375, -748.52209472656, 320.6257019043},
    [84] = {3824.0297851563, -743.60064697266, 321.55737304688},
    [85] = {3826.0712890625, -737.91882324219, 322.12237548828},
    [86] = {3827.953125, -732.681640625, 322.51211547852},
    [87] = {3831.2160644531, -728.17523193359, 323.02102661133},
    [88] = {3833.9792480469, -723.52819824219, 324.43890380859},
    [89] = {3836.6987304688, -718.59381103516, 325.27847290039},
    [90] = {3838.8977050781, -712.91302490234, 325.65661621094},
    [91] = {3841.3771972656, -708.09869384766, 325.76095581055},
    [92] = {3843.2736816406, -702.82037353516, 325.86730957031},
    [93] = {3845.2651367188, -697.27850341797, 325.73693847656},
    [94] = {3847.2492675781, -691.75659179688, 326.13900756836},
    [95] = {3849.2229003906, -686.26416015625, 326.76440429688},
    [96] = {3851.1235351563, -681.22479248047, 327.42443847656},
    [97] = {3851.9775390625, -676.05407714844, 328.30917358398},
    [98] = {3855.0942382813, -671.29089355469, 329.15823364258},
    [99] = {3858.9309082031, -667.04290771484, 330.13702392578},
    [100] = {3863.2644042969, -663.95758056641, 330.66220092773},
    [101] = {3868.0227050781, -668.66174316406, 329.30834960938},
    [102] = {3873.53515625, -667.42462158203, 329.50802612305},
    [103] = {3878.0515136719, -664.30804443359, 330.24487304688},
    [104] = {3880.1843261719, -659.30047607422, 331.61697387695},
    [105] = {3883.2939453125, -654.55578613281, 333.05981445313},
    [106] = {3887.3830566406, -651.18322753906, 333.74557495117},
    [107] = {3891.23828125, -646.423828125, 334.82067871094},
    [108] = {3894.7631835938, -641.7294921875, 336.27960205078},
    [109] = {3898.23046875, -636.95892333984, 336.78570556641},
    [110] = {3901.4267578125, -632.55389404297, 336.63973999023},
    [111] = {3904.9099121094, -627.82781982422, 336.49658203125},
    [112] = {3908.7648925781, -623.80151367188, 337.06600952148},
    [113] = {3912.7756347656, -620.20196533203, 338.34588623047},
    [114] = {3917.3601074219, -616.56683349609, 340.37231445313},
    [115] = {3922.3645019531, -613.57043457031, 341.3044128418},
    [116] = {3927.4645996094, -611.03503417969, 341.05926513672},
    [117] = {3932.6330566406, -609.40026855469, 340.6315612793},
    [118] = {3938.0827636719, -608.11102294922, 341.10919189453},
    [119] = {3944.1198730469, -606.68273925781, 341.07672119141},
    [120] = {3949.7822265625, -605.34307861328, 339.82833862305},
    [121] = {3955.1892089844, -604.06384277344, 338.64910888672},
    [122] = {3960.7351074219, -602.72613525391, 338.53280639648},
    [123] = {3966.1286621094, -601.39099121094, 338.5537109375},
    [124] = {3971.5095214844, -600.90795898438, 337.91943359375},
    [125] = {3972.6413574219, -607.6962890625, 336.67431640625},
    [126] = {3967.6665039063, -609.67889404297, 337.02932739258},
    [127] = {3962.0466308594, -610.35833740234, 337.63613891602},
    [128] = {3956.0825195313, -611.49774169922, 338.05560302734},
    [129] = {3950.5661621094, -612.40661621094, 338.83987426758},
    [130] = {3944.7607421875, -613.28314208984, 339.68988037109},
    [131] = {3939.3012695313, -614.107421875, 339.61148071289},
    [132] = {3934.0927734375, -614.89379882813, 339.3274230957},
    [133] = {3928.7150878906, -616.07073974609, 339.63708496094},
    [134] = {3923.8408203125, -618.46319580078, 340.00659179688},
    [135] = {3918.845703125, -621.8251953125, 339.13784790039},
    [136] = {3914.5246582031, -625.45251464844, 337.36514282227},
    [137] = {3910.9145507813, -629.85186767578, 336.19421386719},
    [138] = {3906.2072753906, -632.19451904297, 336.15798950195},
    [139] = {3901.5300292969, -635.15472412109, 336.63110351563},
    [140] = {3898.5466308594, -639.98895263672, 336.52658081055},
    [141] = {3895.1062011719, -644.53985595703, 335.45138549805},
    [142] = {3891.3439941406, -649.51647949219, 333.85528564453},
    [143] = {3887.5732421875, -653.50720214844, 333.02847290039},
    [144] = {3883.2116699219, -657.94348144531, 332.00570678711},
    [145] = {3879.4267578125, -661.79321289063, 330.93185424805},
    [146] = {3875.0773925781, -666.21697998047, 329.74014282227},
    [147] = {3871.2299804688, -670.14044189453, 329.07760620117},
    [148] = {3867.71484375, -674.13092041016, 328.7033996582},
    [149] = {3864.1589355469, -678.400390625, 328.1725769043},
    [150] = {3860.6928710938, -682.56225585938, 327.39825439453},
    [151] = {3857.1594238281, -686.80487060547, 326.49468994141},
    [152] = {3853.603515625, -691.07434082031, 325.73348999023},
    [153] = {3850.1430664063, -695.2294921875, 325.38928222656},
    [154] = {3846.4050292969, -699.72277832031, 325.68063354492},
    [155] = {3844.1853027344, -704.73498535156, 325.75628662109},
    [156] = {3842.51171875, -709.99920654297, 325.56378173828},
    [157] = {3840.400390625, -714.93951416016, 325.36834716797},
    [158] = {3838.248046875, -719.97637939453, 324.93106079102},
    [159] = {3835.8857421875, -725.50402832031, 323.58203125},
    [160] = {3833.5751953125, -730.91101074219, 321.9089050293},
    [161] = {3831.4055175781, -735.98809814453, 321.2453918457},
    [162] = {3829.1809082031, -741.19396972656, 320.89569091797},
    [163] = {3827.0456542969, -746.19055175781, 320.33087158203},
    [164] = {3825.4689941406, -751.52557373047, 319.04516601563},
    [165] = {3824.4138183594, -756.75738525391, 317.51599121094},
    [166] = {3823.599609375, -762.14739990234, 315.83038330078},
    [167] = {3822.7924804688, -767.53857421875, 314.17007446289},
    [168] = {3821.9479980469, -773.18072509766, 312.46734619141},
    [169] = {3821.2307128906, -779.00708007813, 310.58102416992},
    [170] = {3820.8190917969, -784.83349609375, 308.44354248047},
    [171] = {3821.3615722656, -790.23620605469, 306.08654785156},
    [172] = {3822.5405273438, -795.49566650391, 303.42004394531},
    [173] = {3823.7475585938, -800.83850097656, 300.43609619141},
    [174] = {3825.6831054688, -805.96466064453, 298.09259033203},
    [175] = {3828.5834960938, -810.55975341797, 296.1428527832},
    [176] = {3832.4360351563, -814.68377685547, 294.39910888672},
    [177] = {3836.4104003906, -818.52758789063, 292.89144897461},
    [178] = {3840.5922851563, -821.93811035156, 291.28115844727},
    [179] = {3845.0612792969, -825.25482177734, 289.70501708984},
    [180] = {3849.5185546875, -828.43829345703, 289.45346069336},
    [181] = {3854.1264648438, -831.72705078125, 288.99108886719},
    [182] = {3858.8200683594, -835.07678222656, 287.80236816406},
    [183] = {3863.2001953125, -838.20288085938, 287.63430786133},
    [184] = {3867.873046875, -840.81585693359, 287.21444702148},
    [185] = {3872.5087890625, -843.44696044922, 286.09289550781},
    [186] = {3876.5153808594, -847.10858154297, 284.60357666016},
    [187] = {3880.3500976563, -850.90875244141, 283.6457824707},
    [188] = {3884.3400878906, -854.86285400391, 282.68395996094},
    [189] = {3888.1687011719, -858.65686035156, 281.87548828125},
    [190] = {3891.9165039063, -862.37078857422, 281.24786376953},
    [191] = {3895.8256835938, -866.24481201172, 280.43893432617},
    [192] = {3899.6108398438, -869.99572753906, 279.47280883789},
    [193] = {3902.6186523438, -874.2392578125, 278.45492553711},
    [194] = {3902.6186523438, -874.2392578125, 278.45492553711}
}

--------------------VENDOR--------------------
VendorName = "Bale"
RepairVendor = "Altsoba Ragetotem"

VendorPoints = {
    [1] = {3902.3605957031, -873.16461181641, 278.65951538086},
    [2] = {3907.5671386719, -877.05712890625, 277.98184204102},
    [3] = {3913.1359863281, -880.20715332031, 277.36434936523},
    [4] = {3918.9716796875, -882.94622802734, 276.67016601563},
    [5] = {3925.3161621094, -883.67944335938, 275.57516479492},
    [6] = {3931.6923828125, -883.57403564453, 274.77365112305},
    [7] = {3938.4692382813, -884.3330078125, 273.94390869141},
    [8] = {3944.0029296875, -880.91125488281, 274.97607421875},
    [9] = {3950.0991210938, -877.26745605469, 275.86190795898},
    [10] = {3955.9797363281, -873.80377197266, 275.30282592773},
    [11] = {3961.2094726563, -873.46893310547, 274.41708374023},
    [12] = {3965.3791503906, -878.36761474609, 272.29501342773},
    [13] = {3968.30859375, -883.87084960938, 271.25534057617},
    [14] = {3971.6025390625, -887.74078369141, 270.76483154297},
    [15] = {3973.6433105469, -897.44696044922, 268.54998779297},
    [16] = {3976.7729492188, -902.24176025391, 266.75659179688},
    [17] = {3980.0354003906, -905.97418212891, 265.64263916016},
    [18] = {3984.2282714844, -910.60278320313, 264.42950439453},
    [19] = {3988.8220214844, -914.98510742188, 262.48583984375},
    [20] = {3994.3723144531, -915.61413574219, 259.68695068359},
    [21] = {4001.1320800781, -916.03997802734, 258.98883056641},
    [22] = {4006.3522949219, -916.16351318359, 258.83456420898},
    [23] = {4012.40234375, -915.2890625, 258.58947753906},
    [24] = {4018.9616699219, -914.99078369141, 258.27575683594},
    [25] = {4025.884765625, -914.68072509766, 258.05731201172},
    [26] = {4032.4416503906, -914.52606201172, 257.8603515625},
    [27] = {4038.5458984375, -913.29779052734, 257.8249206543},
    [28] = {4044.6596679688, -914.078125, 257.69097900391},
    [29] = {4050.9653320313, -913.34020996094, 257.56094360352},
    [30] = {4057.6457519531, -912.86322021484, 256.68267822266},
    [31] = {4062.9926757813, -908.34375, 256.54873657227},
    [32] = {4069.7280273438, -906.0146484375, 255.9271697998},
    [33] = {4076.0568847656, -903.26275634766, 255.64910888672},
    [34] = {4083.0053710938, -902.41851806641, 255.76536560059},
    [35] = {4089.8718261719, -901.89123535156, 255.74383544922},
    [36] = {4095.7006835938, -900.28948974609, 255.27696228027},
    [37] = {4101.9624023438, -900.48901367188, 254.88966369629},
    [38] = {4108.4877929688, -902.06225585938, 255.13320922852},
    [39] = {4115.3452148438, -903.49719238281, 255.62210083008},
    [40] = {4122.0244140625, -904.31225585938, 255.68295288086},
    [41] = {4129.146484375, -905.86566162109, 255.66645812988},
    [42] = {4134.7670898438, -907.68933105469, 256.79180908203},
    [43] = {4140.3813476563, -910.59283447266, 258.83786010742},
    [44] = {4144.9370117188, -914.15496826172, 261.03305053711},
    [45] = {4150.212890625, -917.48229980469, 263.23010253906},
    [46] = {4147.861328125, -922.98309326172, 265.13430786133},
    [47] = {4145.2919921875, -928.87664794922, 266.82247924805},
    [48] = {4143.67578125, -934.74078369141, 268.68591308594},
    [49] = {4142.064453125, -940.71539306641, 269.94708251953},
    [50] = {4141.1591796875, -946.87152099609, 272.15365600586},
    [51] = {4141.4853515625, -953.04919433594, 276.50796508789},
    [52] = {4142.6040039063, -958.75323486328, 279.1184387207},
    [53] = {4146.875, -962.67626953125, 279.68020629883},
    [54] = {4152.60546875, -961.10913085938, 280.31469726563},
    [55] = {4157.1909179688, -956.66613769531, 281.01608276367},
    [56] = {4161.7163085938, -953.04852294922, 281.61114501953},
    [57] = {4166.1665039063, -949.01312255859, 282.11148071289},
    [58] = {4170.6625976563, -944.74908447266, 282.39797973633},
    [59] = {4175.1025390625, -940.49401855469, 282.55743408203},
    [60] = {4179.3583984375, -936.57196044922, 282.69348144531},
    [61] = {4183.9814453125, -932.48767089844, 282.82440185547},
    [62] = {4188.7592773438, -928.31951904297, 282.96936035156},
    [63] = {4193.5595703125, -924.16375732422, 283.09527587891},
    [64] = {4197.8999023438, -920.31994628906, 283.25103759766},
    [65] = {4202.3969726563, -916.33734130859, 283.38433837891},
    [66] = {4207.478515625, -911.83709716797, 283.49377441406},
    [67] = {4211.8803710938, -907.20147705078, 283.56643676758},
    [68] = {4216.4702148438, -903.13677978516, 283.63952636719},
    [69] = {4220.8227539063, -899.09344482422, 283.69073486328},
    [70] = {4224.509765625, -894.46160888672, 283.83355712891},
    [71] = {4228.9497070313, -890.52947998047, 283.94177246094},
    [72] = {4233.3330078125, -886.64776611328, 284.04925537109},
    [73] = {4237.9584960938, -882.55151367188, 284.18719482422},
    [74] = {4242.4125976563, -878.60675048828, 284.15997314453},
    [75] = {4246.8168945313, -874.70611572266, 284.44259643555},
    [76] = {4251.4077148438, -870.81878662109, 285.87225341797},
    [77] = {4256.1977539063, -866.90124511719, 287.13027954102},
    [78] = {4260.974609375, -863.32965087891, 286.51733398438},
    [79] = {4266.0986328125, -859.86010742188, 284.70956420898},
    [80] = {4271.0126953125, -856.55706787109, 283.96951293945},
    [81] = {4276.1274414063, -853.31884765625, 284.47030639648},
    [82] = {4281.8920898438, -851.95697021484, 285.02871704102},
    [83] = {4288.0776367188, -852.07287597656, 285.43685913086},
    [84] = {4294.1484375, -851.89239501953, 285.75595092773},
    [85] = {4300.6572265625, -851.69885253906, 286.16458129883},
    [86] = {4306.880859375, -851.51379394531, 286.68661499023},
    [87] = {4313.0810546875, -851.45660400391, 287.29644775391},
    [88] = {4319.142578125, -851.5810546875, 287.76806640625},
    [89] = {4325.0737304688, -851.56781005859, 288.00952148438},
    [90] = {4330.9760742188, -851.55456542969, 288.29443359375},
    [91] = {4337.2114257813, -851.56744384766, 288.63143920898},
    [92] = {4343.1616210938, -851.60089111328, 289.0905456543},
    [93] = {4349.4345703125, -851.65106201172, 289.57553100586},
    [94] = {4355.5747070313, -851.70965576172, 290.0798034668},
    [95] = {4361.6674804688, -851.76782226563, 290.16958618164},
    [96] = {4368.1025390625, -851.82922363281, 290.39196777344},
    [97] = {4374.2333984375, -851.88775634766, 290.76058959961},
    [98] = {4380.4399414063, -851.94702148438, 291.11422729492},
    [99] = {4386.666015625, -852.00646972656, 291.46118164063},
    [100] = {4393.1391601563, -852.06823730469, 291.84661865234},
    [101] = {4399.650390625, -852.13037109375, 292.22863769531},
    [102] = {4405.923828125, -852.19024658203, 292.59564208984},
    [103] = {4412.2578125, -852.25073242188, 292.85061645508},
    [104] = {4418.4741210938, -852.31005859375, 292.92163085938},
    [105] = {4424.9091796875, -852.37152099609, 293.23937988281},
    [106] = {4430.7255859375, -852.42700195313, 293.58193969727},
    [107] = {4436.9038085938, -852.48602294922, 293.76000976563},
    [108] = {4443.2338867188, -852.54644775391, 293.89849853516},
    [109] = {4449.2216796875, -852.62713623047, 294.18450927734},
    [110] = {4455.294921875, -852.70892333984, 294.7526550293},
    [111] = {4461.3012695313, -852.82409667969, 295.39868164063},
    [112] = {4467.2954101563, -853.02258300781, 295.81518554688},
    [113] = {4473.2983398438, -853.16137695313, 296.22229003906},
    [114] = {4479.2827148438, -852.88055419922, 296.50524902344},
    [115] = {4485.298828125, -852.05230712891, 296.54553222656},
    [116] = {4491.57421875, -851.14489746094, 296.54553222656},
    [117] = {4498.2124023438, -850.18493652344, 296.54977416992},
    [118] = {4505.021484375, -850.08508300781, 296.55465698242},
    [119] = {4510.9858398438, -850.76403808594, 296.59008789063},
    [120] = {4517.6743164063, -851.19616699219, 296.56063842773},
    [121] = {4523.7827148438, -851.5908203125, 296.68905639648},
    [122] = {4529.5493164063, -851.96343994141, 297.25042724609},
    [123] = {4535.8857421875, -852.37274169922, 297.88247680664},
    [124] = {4541.9755859375, -852.26013183594, 298.57592773438},
    [125] = {4548.5405273438, -852.03912353516, 299.21853637695},
    [126] = {4555.0869140625, -851.81872558594, 299.77969360352},
    [127] = {4560.9658203125, -851.43585205078, 300.12237548828},
    [128] = {4566.8598632813, -850.04132080078, 300.23208618164},
    [129] = {4572.24609375, -847.30609130859, 300.19982910156},
    [130] = {4577.2924804688, -843.81262207031, 300.09332275391},
    [131] = {4582.3540039063, -839.90014648438, 299.99249267578},
    [132] = {4586.9565429688, -836.34283447266, 300.02676391602},
    [133] = {4591.7104492188, -832.75726318359, 300.09280395508},
    [134] = {4596.9526367188, -829.12414550781, 300.14031982422},
    [135] = {4601.8120117188, -825.94409179688, 300.18634033203},
    [136] = {4606.791015625, -822.70446777344, 300.03002929688},
    [137] = {4611.8852539063, -819.66870117188, 300.03518676758},
    [138] = {4617.0854492188, -816.73809814453, 299.94903564453},
    [139] = {4622.2290039063, -813.84252929688, 299.9362487793},
    [140] = {4627.8286132813, -810.69012451172, 299.94696044922},
    [141] = {4633.087890625, -807.72918701172, 299.93075561523},
    [142] = {4638.2895507813, -804.80096435547, 299.88723754883},
    [143] = {4643.6069335938, -801.80731201172, 300.04138183594},
    [144] = {4648.9248046875, -798.81372070313, 300.08721923828},
    [145] = {4654.1259765625, -795.88549804688, 299.97872924805},
    [146] = {4659.3525390625, -792.94323730469, 300.10568237305},
    [147] = {4664.5869140625, -789.99633789063, 299.96490478516},
    [148] = {4669.9794921875, -787.306640625, 299.90982055664},
    [149] = {4675.5864257813, -785.40447998047, 299.93740844727},
    [150] = {4681.5336914063, -783.73364257813, 299.95852661133},
    [151] = {4687.5400390625, -782.16717529297, 299.95700073242},
    [152] = {4693.5302734375, -780.61486816406, 299.95129394531},
    [153] = {4699.6953125, -779.01721191406, 299.95779418945},
    [154] = {4705.298828125, -777.56524658203, 299.95779418945},
    [155] = {4711.1782226563, -776.04156494141, 299.98690795898},
    [156] = {4717.0390625, -774.52270507813, 300.10888671875},
    [157] = {4723.01953125, -772.97064208984, 300.08798217773},
    [158] = {4728.6372070313, -770.42041015625, 299.96054077148},
    [159] = {4733.6577148438, -767.54089355469, 299.95837402344},
    [160] = {4738.7299804688, -764.57928466797, 299.95965576172},
    [161] = {4744.18359375, -761.47772216797, 299.96453857422},
    [162] = {4750.1137695313, -758.57073974609, 299.96063232422},
    [163] = {4756.359375, -755.98791503906, 299.95831298828},
    [164] = {4761.8334960938, -753.83135986328, 299.95831298828},
    [165] = {4767.3959960938, -751.63989257813, 299.95831298828},
    [166] = {4773.2983398438, -750.00146484375, 299.95831298828},
    [167] = {4779.5649414063, -748.45599365234, 299.95831298828},
    [168] = {4785.4467773438, -747.29626464844, 299.95541381836},
    [169] = {4791.5712890625, -746.28747558594, 299.95739746094},
    [170] = {4797.5361328125, -745.30499267578, 299.95846557617},
    [171] = {4803.69140625, -744.59399414063, 299.95590209961},
    [172] = {4809.6967773438, -743.98901367188, 299.98403930664},
    [173] = {4815.46484375, -743.40783691406, 300.10504150391},
    [174] = {4821.6879882813, -742.78082275391, 300.22323608398},
    [175] = {4827.5703125, -742.18823242188, 300.37200927734},
    [176] = {4833.4858398438, -741.59216308594, 300.70333862305},
    [177] = {4839.3681640625, -740.99957275391, 300.98748779297},
    [178] = {4845.8876953125, -740.52117919922, 301.38079833984},
    [179] = {4852.3706054688, -740.45574951172, 301.85064697266},
    [180] = {4858.9008789063, -740.39953613281, 302.27520751953},
    [181] = {4865.1362304688, -740.36108398438, 302.63897705078},
    [182] = {4871.0551757813, -740.32464599609, 302.97131347656},
    [183] = {4877.5859375, -740.28436279297, 303.25439453125},
    [184] = {4884.0498046875, -740.24456787109, 303.51907348633},
    [185] = {4890.3232421875, -740.20587158203, 303.5768737793},
    [186] = {4896.5673828125, -740.13824462891, 303.91665649414},
    [187] = {4902.8071289063, -739.88159179688, 304.52401733398},
    [188] = {4909.1665039063, -739.12487792969, 305.34020996094},
    [189] = {4915.37890625, -738.25140380859, 306.1692199707},
    [190] = {4921.7622070313, -737.50952148438, 306.70941162109},
    [191] = {4927.6708984375, -737.23529052734, 307.35018920898},
    [192] = {4934.3154296875, -737.46246337891, 307.96115112305},
    [193] = {4940.4174804688, -738.14654541016, 308.38284301758},
    [194] = {4946.2260742188, -738.79779052734, 308.75082397461},
    [195] = {4951.9877929688, -739.44372558594, 309.25735473633},
    [196] = {4958.8090820313, -740.20849609375, 309.6413269043},
    [197] = {4965.5263671875, -740.96154785156, 309.86447143555},
    [198] = {4972.158203125, -741.705078125, 310.68112182617},
    [199] = {4978.3740234375, -742.40191650391, 311.76092529297},
    [200] = {4984.150390625, -743.47027587891, 312.44262695313},
    [201] = {4990.0698242188, -744.86871337891, 312.94619750977},
    [202] = {4996.25, -746.28643798828, 313.43255615234},
    [203] = {5002.7436523438, -747.73229980469, 314.3938293457},
    [204] = {5008.6474609375, -748.9873046875, 315.45858764648},
    [205] = {5014.791015625, -750.21099853516, 316.60668945313},
    [206] = {5020.4702148438, -751.27850341797, 317.70852661133},
    [207] = {5026.8999023438, -752.03497314453, 318.98501586914},
    [208] = {5033.5541992188, -752.08813476563, 320.189453125},
    [209] = {5039.3994140625, -752.12097167969, 321.20602416992},
    [210] = {5046.5395507813, -752.16107177734, 322.38571166992},
    [211] = {5053.5649414063, -752.20056152344, 323.47268676758},
    [212] = {5060.6098632813, -752.24017333984, 324.42361450195},
    [213] = {5067.2641601563, -752.27752685547, 325.03076171875},
    [214] = {5073.7646484375, -752.189453125, 325.57568359375},
    [215] = {5080.0229492188, -751.75860595703, 326.26449584961},
    [216] = {5085.896484375, -750.57574462891, 327.06530761719},
    [217] = {5092.4326171875, -749.03002929688, 328.06488037109},
    [218] = {5098.4282226563, -747.74981689453, 328.92993164063},
    [219] = {5105.0986328125, -746.44024658203, 329.36892700195},
    [220] = {5111.3388671875, -745.63543701172, 329.38140869141},
    [221] = {5117.2612304688, -744.97204589844, 329.44180297852},
    [222] = {5123.5693359375, -744.85028076172, 329.64706420898},
    [223] = {5129.9555664063, -744.7607421875, 330.08602905273},
    [224] = {5136.1044921875, -744.67456054688, 330.82168579102},
    [225] = {5142.4731445313, -744.58526611328, 331.8821105957},
    [226] = {5148.5366210938, -744.50030517578, 333.16250610352},
    [227] = {5154.7524414063, -744.39709472656, 334.60601806641},
    [228] = {5160.5854492188, -743.46350097656, 336.05603027344},
    [229] = {5166.3793945313, -742.06719970703, 337.48138427734},
    [230] = {5171.6108398438, -739.58245849609, 338.72393798828},
    [231] = {5177.7690429688, -737.86077880859, 339.90975952148},
    [232] = {5182.3559570313, -734.14990234375, 340.78317260742},
    [233] = {5187.0883789063, -729.56243896484, 341.41632080078},
    [234] = {5191.974609375, -726.37493896484, 341.75134277344},
    [235] = {5197.6049804688, -722.7216796875, 342.18084716797},
    [236] = {5200.7470703125, -717.77447509766, 342.27508544922},
    [237] = {5204.0336914063, -713.41387939453, 342.5126953125},
    [238] = {5207.4047851563, -708.98498535156, 342.78176879883},
    [239] = {5205.37109375, -703.96447753906, 342.79501342773},
    [240] = {5198.0073242188, -703.60571289063, 342.97741699219},
    [241] = {5191.9165039063, -704.60980224609, 343.42391967773},
    [242] = {5185.5932617188, -704.1796875, 343.72235107422},
    [243] = {5179.5991210938, -701.65325927734, 341.58361816406},
    [244] = {5175.595703125, -697.10687255859, 338.89346313477},
    [245] = {5178.5751953125, -692.27551269531, 336.90805053711},
    [246] = {5182.1298828125, -687.58447265625, 334.74276733398},
    [247] = {5185.095703125, -682.2744140625, 331.72796630859},
    [248] = {5186.8569335938, -676.67614746094, 328.50427246094},
    [249] = {5187.7490234375, -670.91918945313, 325.56323242188},
    [250] = {5188.8178710938, -665.25109863281, 323.8596496582},
    [251] = {5190.5834960938, -658.50482177734, 323.20477294922},
    [252] = {5192.8754882813, -653.12530517578, 323.65417480469},
    [253] = {5195.9750976563, -647.99493408203, 323.95373535156},
    [254] = {5200.2358398438, -644.07928466797, 324.51007080078},
    [255] = {5205.5971679688, -641.2041015625, 325.7080078125},
    [256] = {5211.7890625, -638.47119140625, 327.01779174805},
    [257] = {5210.6206054688, -632.7548828125, 327.31985473633},
    [258] = {5211.642578125, -627.32427978516, 327.69860839844},
    [259] = {5213.5498046875, -621.90075683594, 327.98156738281},
    [260] = {5215.8813476563, -616.35461425781, 328.1208190918},
    [261] = {5216.3544921875, -610.97967529297, 328.17407226563},
    [262] = {5214.46875, -605.29620361328, 328.33221435547},
    [263] = {5213.8940429688, -599.59057617188, 328.78796386719},
    [264] = {5215.322265625, -593.27789306641, 328.94046020508},
    [265] = {5216.4536132813, -587.5791015625, 328.76968383789},
    [266] = {5216.0249023438, -581.52020263672, 328.65731811523},
    [267] = {5216.6713867188, -575.84381103516, 328.75430297852},
    [268] = {5219.7353515625, -570.35882568359, 328.9065246582},
    [269] = {5221.98046875, -565.2099609375, 329.06198120117},
    [270] = {5226.1840820313, -561.17810058594, 328.84432983398},
    [271] = {5230.6376953125, -556.9921875, 328.49984741211},
    [272] = {5235.3901367188, -552.93359375, 328.03411865234},
    [273] = {5240.3979492188, -548.96771240234, 327.35266113281},
    [274] = {5244.96484375, -545.01055908203, 326.3786315918},
    [275] = {5248.8115234375, -539.82104492188, 324.87835693359},
    [276] = {5252.490234375, -534.15057373047, 321.78881835938},
    [277] = {5255.7900390625, -529.01037597656, 318.05075073242},
    [278] = {5258.90234375, -523.54119873047, 317.38751220703},
    [279] = {5260.9887695313, -518.33734130859, 317.28012084961},
    [280] = {5262.798828125, -512.77227783203, 317.25701904297},
    [281] = {5262.826171875, -507.48303222656, 317.49685668945},
    [282] = {5262.81640625, -501.92730712891, 317.49682617188},
    [283] = {5262.806640625, -496.49029541016, 317.49682617188},
    [284] = {5262.7973632813, -491.23590087891, 317.4958190918},
    [285] = {5262.7861328125, -485.96871948242, 317.48977661133},
    [286] = {5260.6572265625, -480.12631225586, 317.78750610352},
    [287] = {5257.591796875, -474.7292175293, 318.87255859375},
    [288] = {5254.7827148438, -469.61196899414, 319.63409423828},
    [289] = {5251.8037109375, -463.66357421875, 320.67443847656},
    [290] = {5249.1420898438, -458.25, 321.31619262695},
    [291] = {5246.763671875, -452.70568847656, 322.00814819336},
    [292] = {5245.1635742188, -446.79724121094, 320.88259887695},
    [293] = {5243.5224609375, -440.66314697266, 320.78671264648},
    [294] = {5241.8959960938, -434.95104980469, 321.97705078125},
    [295] = {5238.8828125, -428.99792480469, 323.001953125},
    [296] = {5235.0698242188, -423.81875610352, 324.28652954102},
    [297] = {5231.1674804688, -419.4033203125, 327.19998168945},
    [298] = {5226.896484375, -414.55184936523, 329.51638793945},
    [299] = {5222.8896484375, -409.8151550293, 330.09332275391},
    [300] = {5219.0747070313, -405.05212402344, 329.95764160156},
    [301] = {5215.4536132813, -400.33599853516, 330.39767456055},
    [302] = {5212.0024414063, -395.48916625977, 330.36874389648},
    [303] = {5208.5278320313, -390.61215209961, 330.03485107422},
    [304] = {5204.943359375, -385.90963745117, 330.43103027344},
    [305] = {5201.0346679688, -381.23641967773, 330.79992675781},
    [306] = {5197.1342773438, -376.61764526367, 331.50698852539},
    [307] = {5193.0561523438, -371.78790283203, 332.5309753418},
    [308] = {5188.9716796875, -366.9508972168, 333.81201171875},
    [309] = {5184.9794921875, -362.22299194336, 335.24081420898},
    [310] = {5180.806640625, -357.60440063477, 336.98831176758},
    [311] = {5176.3989257813, -353.1630859375, 338.80773925781},
    [312] = {5171.9252929688, -349.42642211914, 340.60046386719},
    [313] = {5166.615234375, -346.58343505859, 342.62850952148},
    [314] = {5160.3779296875, -344.80895996094, 344.70538330078},
    [315] = {5153.984375, -344.26086425781, 347.1257019043},
    [316] = {5148.1372070313, -344.5234375, 349.09783935547},
    [317] = {5141.5390625, -345.4914855957, 351.44528198242},
    [318] = {5135.8505859375, -346.87307739258, 353.18090820313},
    [319] = {5130.099609375, -348.43591308594, 354.65515136719},
    [320] = {5123.68359375, -350.08908081055, 355.91976928711},
    [321] = {5117.7612304688, -351.56088256836, 356.76440429688},
    [322] = {5112.3310546875, -352.91946411133, 357.26913452148},
    [323] = {5105.1220703125, -354.65863037109, 357.15017700195},
    [324] = {5098.4067382813, -356.40417480469, 357.21908569336},
    [325] = {5094.9970703125, -357.65872192383, 357.26419067383, "Repair"}
}

DeleteItems = {[1] = {"OOX-09/HL Distress Beacon"}, [2] = {"Patch of Tainted Skin"}} -- 要删除的垃圾东西

--------------------OPTIONS--------------------
PULSE_DELAY = 0.25
START_DELAY = 0.0
DRAW_DELAY = 0.05

function GetProximalTolerance()
    local PROXIMAL_TOLERANCE = 4.4
    if Player.IsMounted() then
        return PROXIMAL_TOLERANCE * 2
    else
        return PROXIMAL_TOLERANCE
    end
end

IGNORE_LOS = true
STRICT_FOLLOW = true
SKIP_FAR_POINTS = false
RELOOP = true

--------------------IMPORTANT--------------------
MAX_LOOT_DIST = 30
LOOT_ON_VENDOR_PATH = true
SAFE_LOOTING = true -- Does not loot unit if it gets aggro

CLEAR_VENDOR_PATH = true -- Clears Vendor Path too (for safety), if has mount and set to FALSE will mount up (bit risky)
MOUNT_WHILE_GRINDING = true -- Mounts if targets are > mountCutOffDist dist from player or nil
MOUNT_CUT_OFF_DIST = 75

DC_ON_ITEM_BREAK = false -- If ANY inventory item breaks (Red) ==> DC [good for long afk sessions]
DC_HORDE_NEARBY = false

RANDOM_MAX = 100 -- Use values between 1 to 100 (100 varies pathing by 1 unit)

PULL_RANGE = 35 -- mage hunter
MELEE_RANGE = 10 -- hunter
LEVEL_MINUS = 6 -- don't attack targets below this lvl diff
LEVEL_PLUS = 4 -- don't attack targets above this lvl diff

POT_UP_HP = 25
POT_UP_MANA = 12

-- These are Auto Set
EatAtHP = 70
DrinkAtMana = 50
RECOVER_TILL_PERCENT = 88 -- once needs to drink/eat will do so till this HP

KITE_ENABLED = true -- Kite when possible

MIN_BAG_SLOTS = 1

--------------------ALGORITHM--------------------
AtEnd = false -- do not touch

LastPulseTime = wow.GetTime() + START_DELAY
NextPulseTime = LastPulseTime + PULSE_DELAY

LastDrawTime = wow.GetTime() + START_DELAY
NextDrawTime = LastPulseTime + DRAW_DELAY

Frame = wow.CreateFrame("Frame")
Frame.elapsed = 1

StuckTime = 0

-- Draw Shit
DestX = Waypoints[1][1]
DestY = Waypoints[1][2]
DestZ = Waypoints[1][3]

PlayerStatus = "WAYPOINT"

function Exit(caller)
    Log.WriteLine('Exit called by: ' .. caller .. '()')
    Frame:SetScript("OnUpdate", nil)
end

local function DismountCheck()
    if Player.IsMounted() then
        wow.Dismount()
    end
end

local function ReadyToDraw()
    local timeNow = wow.GetTime()
    if timeNow < NextDrawTime then
        return false
    end
    LastDrawTime = timeNow
    NextDrawTime = LastDrawTime + DRAW_DELAY
    return true
end

local function ReadyToPulse()
    local timeNow = wow.GetTime()
    if timeNow < NextPulseTime then
        return false
    end
    LastPulseTime = timeNow
    NextPulseTime = LastPulseTime + PULSE_DELAY
    return true
end

local function ArrayContains(arr, search)
    for i = 1, #arr, 1 do
        if arr[i] == search then
            return true
        end
    end
    return false
end

local function Sleep(secs)
    local timeNow = wow.GetTime()
    if timeNow < NextPulseTime then -- since this func may be used several times in 1 cycle
        local overheadWait = NextPulseTime - timeNow;
        NextPulseTime = timeNow + overheadWait + secs
    else
        NextPulseTime = timeNow + secs
    end
end

function GetVendorSlot(itemName)
    for i = 1, 40 do
        local name, texture, price, quantity, numAvailable, isUsable, extendedCost = wow.GetMerchantItemInfo(i);
        if name == nil then
            return -1
        elseif name == itemName then
            return i
        end
    end
end

PathIndex = 1
LOST_FLAGS = wow.bit.bor(0x10, 0x100)

local function PositionAggroCount()
    local count = 0
    for i = 1, Object:Count() do
        local object = Object:Get(i)
        if object ~= nil then
            if object:IsEnemy() and not object:IsDead() then
                local aggroRad = object:Level() - Player:Level() + 20 + 3 -- suppost +20 imma to be safe +5
                if object:Distance() < aggroRad then
                    count = count + 1
                end
            end
        end
    end
    return count
end

-- Scan whole table and find closest point and always move to it (includes LOS checks)
-- Doesnt support jumping YET
local function MoveToClosestWaypoint()
    local px, py, pz = Player:Position()
    local closestIndex = 1
    local closestDist = 9999999
    local foundWaypoint = false

    -- 寻找最近的waypoint
    for i = PathIndex, #Waypoints, 1 do
        local waypoint = Waypoints[i]
        if waypoint ~= nil then
            local dist = wow.CalculateDistance(px, py, pz, waypoint[1], waypoint[2], waypoint[3])
            if dist <= closestDist and dist > GetProximalTolerance() then
                if i == #Waypoints then
                    AtEnd = true
                end
                if IGNORE_LOS == true or TraceLine(px, py, pz + 2.5, waypoint[1], waypoint[2], waypoint[3] + 2.5, LOST_FLAGS) == nil then
                    foundWaypoint = true
                    closestIndex = i
                    closestDist = dist
                end
            end
        end
    end

    if foundWaypoint then
        PathIndex = closestIndex
    else
        Log.WriteLine('Found No path in LOS!')
        PathIndex = 1;
        Player.Jump()
    end

    Navigator.MoveTo(Waypoints[closestIndex])
end

AtVendor = false
AtStartAfterVendor = false
SellComplete = false
TalkedToVendor = false
VendorPathIndex = 1

local function SetIndexToClosest(ignoreVendor, limit)
    local closestIndex = 1
    local closestDist = 9999999
    local foundWaypoint = false
    local closestIsVendor = false
    local endWaypointCount = #Waypoints
    local startIndex = 1

    if limit ~= nil then
        startIndex = PathIndex - limit
        endWaypointCount = PathIndex + limit

        if startIndex < 1 then
            startIndex = 1
        end
        if endWaypointCount > #Waypoints then
            endWaypointCount = #Waypoints
        end
    end

    -- 寻找距离我最近的路径点
    local px, py, pz = Player:Position()
    for i = startIndex, endWaypointCount, 1 do
        local waypoint = Waypoints[i]
        if waypoint ~= nil then
            local dist = wow.CalculateDistance(px, py, pz, waypoint[1], waypoint[2], waypoint[3])
            if dist <= closestDist then
                if IGNORE_LOS == true or TraceLine(px, py, pz + 2.5, waypoint[1], waypoint[2], waypoint[3] + 2.5, LOST_FLAGS) == nil then
                    foundWaypoint = true
                    closestIndex = i
                    closestDist = dist
                    closestIsVendor = false
                end
            end
        end
    end

    -- 忽略Vendor
    if ignoreVendor then
        if foundWaypoint then
            PathIndex = closestIndex
            Log.WriteLine("Starting at grind path at idx " .. PathIndex)
        end
        return
    end

    -- 是否有更近的vendor point?
    for i = 1, #VendorPoints, 1 do
        local waypoint = VendorPoints[i]
        if waypoint ~= nil then
            local dist = wow.CalculateDistance(px, py, pz, waypoint[1], waypoint[2], waypoint[3])
            if dist <= closestDist then
                if IGNORE_LOS == true or TraceLine(px, py, pz + 2.5, waypoint[1], waypoint[2], waypoint[3] + 2.5, LOST_FLAGS) == nil then
                    foundWaypoint = true
                    closestIndex = i
                    closestDist = dist
                    closestIsVendor = true
                end
            end
        end
    end

    if not foundWaypoint then
        Log.WriteLine('WARNING: Could not find a close point in SetIndexToClosest()')
        return
    end
    if closestIsVendor then
        VendorPathIndex = closestIndex
        Log.WriteLine("Walking back to leveling path from vendor from idx " .. VendorPathIndex)
        SellComplete = true
        AtStartAfterVendor = false
    else
        PathIndex = closestIndex
        Log.WriteLine("Starting at grind path at idx " .. PathIndex)
    end
end

LastIndex = nil
LastIndexCount = 0

function FirstTickApply()
    if Player:IsHunter() then
        EatAtHP = 69
        DrinkAtMana = 33
    elseif Player:IsMage() then
        Log.WriteLine("Applying Mage Mana/HP Preset!")
        EatAtHP = 75
        DrinkAtMana = 75
    end
end

FirstTickApply()
FirstTick = true

local function MoveToNextWaypoint()
    if FirstTick == true then -- 只执行一次
        FirstTick = false
        SetIndexToClosest()
    end

    -- 移动到位了?
    local nextPoint = Waypoints[PathIndex]
    if nextPoint ~= nil then
        if Player:DistanceFrom(nextPoint) <= GetProximalTolerance() then
            if PathIndex < #Waypoints then
                PathIndex = PathIndex + 1
                Log.WriteLine('Moving to idx {' .. PathIndex .. '/' .. #Waypoints .. '}')
                return -- (1) 移动到位, 下一个点
            else
                AtEnd = true
            end
        end
    end

    -- 卡住了?
    if PathIndex == LastIndex then
        LastIndexCount = LastIndexCount + 1
        StuckTime = StuckTime + PULSE_DELAY
    else
        LastIndexCount = 0
        StuckTime = 0
    end
    if LastIndexCount > 20 and (PathIndex < #Waypoints - 2) then
        Log.WriteLine('Appears to be STUCK: at idx=' .. PathIndex)
        Player.Jump()
        PathIndex = PathIndex + 1
        AtEnd = PathIndex > #Waypoints
        return -- (2) 卡主了
    end
    if PathIndex < 1 then
        PathIndex = 1
    elseif PathIndex > #Waypoints then
        PathIndex = #Waypoints
        AtEnd = true
    end

    -- Move
    if nextPoint ~= nil then
        local rnd = (math.random(-RANDOM_MAX, RANDOM_MAX) / 100)
        DestX = nextPoint[1] + rnd
        DestY = nextPoint[2] + rnd
        DestZ = nextPoint[3] + rnd
    end
    PlayerStatus = "WAYPOINT"
    local px, py, pz = Player:Position()
    local distToNext = wow.CalculateDistance(px, py, pz, nextPoint[1], nextPoint[2], nextPoint[3])
    if not SKIP_FAR_POINTS or (SKIP_FAR_POINTS and distToNext < 50) then
        if IGNORE_LOS or TraceLine(px, py, pz + 2.5, nextPoint[1], nextPoint[2], nextPoint[3] + 2.5, LOST_FLAGS) == nil then
            Navigator.MoveTo(DestX, DestY, DestZ)
        end
    else
        if SKIP_FAR_POINTS then
            Log.WriteLine('*Skipping* to idx {' .. PathIndex .. '/' .. #Waypoints .. '}')
            PathIndex = PathIndex + 1
            AtEnd = PathIndex > #Waypoints
            return -- (3) 忽略远点, 直接下一个点
        else
            Log.WriteLine('*Waiting* for player to be close to path...')
        end
    end

    LastIndex = PathIndex
end

-- Processes path relooping and Exit()
local function PathEndCheck(reloop)
    if not AtEnd then
        return
    end

    if reloop then
        ReloopWaypoint(Waypoints)
    else
        Log.WriteLine('Finished Pathing!!!')
        Exit('PathEndCheck')
    end
end

function ReloopWaypoint(waypoints)
    local startWaypoint = waypoints[1]
    local px, py, pz = Player:Position()
    if IGNORE_LOS or TraceLine(px, py, pz + 2.5, startWaypoint[1], startWaypoint[2], startWaypoint[3] + 2.5) == nil then
        AtEnd = false
        local firstWaypoint = waypoints[1]
        local lastWaypoint = waypoints[#waypoints]
        if wow.CalculateDistance(firstWaypoint, lastWaypoint) > 50 then
            Log.WriteLine('Reversing Path!!!')
            local i, j = 1, #waypoints
            while i < j do
                waypoints[i], waypoints[j] = waypoints[j], waypoints[i]
                i = i + 1
                j = j - 1
            end
        else
            Log.WriteLine('ReLooping Path!!!')
        end

        PathIndex = 1
    else
        Log.WriteLine('Cannot ReLoop as Start is not in LOS!')
        PathIndex = 1
    end
end

function HasMount()
    if MOUNT_NAME == "" or MOUNT_NAME == nil then
        return false
    end
    return Bag.Found(MOUNT_NAME)
end

local function HasManaGem()
    if not Player:IsMage() then
        return false
    end
    return Bag.Found("Mana Agate", "Mana Jade", "Mana Citrine")
end

local function VendorPath(toVendor)
    if Player:IsHunter() and HunterBuff ~= "Aspect of the Cheetah" and not HasMount() then
        HunterBuff = "Aspect of the Cheetah"
    end

    local nextPoint = VendorPoints[VendorPathIndex] -- return is imp to always assign next xyz correctly
    if nextPoint ~= nil then
        if Player:DistanceFrom(nextPoint[1], nextPoint[2], nextPoint[3]) <= GetProximalTolerance() then
            if toVendor and VendorPathIndex <= #VendorPoints then
                VendorPathIndex = VendorPathIndex + 1
            elseif VendorPathIndex > 1 then
                VendorPathIndex = VendorPathIndex - 1
            end
            Log.WriteLine('Moving to vendor idx {' .. VendorPathIndex .. '/' .. #VendorPoints .. '}')
        end

        -- repair or stop
        local action = nextPoint[4]
        if not toVendor and action ~= nil then
            if action == "Repair" then
                Log.WriteLine("Going to Repair Vendor...")
                Player.Repair(RepairVendor)
                Sleep(10)

                if toVendor and VendorPathIndex <= #VendorPoints then
                    VendorPathIndex = VendorPathIndex + 1
                elseif VendorPathIndex > 1 then
                    VendorPathIndex = VendorPathIndex - 1
                end
                return -- 退出
            elseif action == "Stop" then
                Log.WriteLine("Stopping!")
                wow.SendKey(83, 123) -- S
                Sleep(3)

                if toVendor and VendorPathIndex <= #VendorPoints then
                    VendorPathIndex = VendorPathIndex + 1
                elseif VendorPathIndex > 1 then
                    VendorPathIndex = VendorPathIndex - 1
                end
                return -- 退出
            end
        end
    end

    -- Move to next point
    local moveToXYZ = VendorPoints[VendorPathIndex]
    if moveToXYZ ~= nil then
        PlayerStatus = "VENDOR"
        local rnd = math.random(-RANDOM_MAX, RANDOM_MAX) / 100
        DestX = moveToXYZ[1] + rnd
        DestY = moveToXYZ[2] + rnd
        DestZ = moveToXYZ[3] + rnd
        if VendorPathIndex == #VendorPoints then -- 最后一点
            Navigator.MoveTo(moveToXYZ[1], moveToXYZ[2], moveToXYZ[3])
        else
            Navigator.MoveTo(moveToXYZ[1] + rnd, moveToXYZ[2] + rnd, moveToXYZ[3] + rnd)
        end
    end

    if toVendor then
        AtVendor = VendorPathIndex >= #VendorPoints
    else
        AtStartAfterVendor = VendorPathIndex <= 1
        SetIndexToClosest(true)
    end
end

GoingToVendor = false

local function EmptyBagsSetup()
    -- Check Drinks + Food
    -- Check Arrows +/ if equipped too
    if #VendorPoints <= 1 then -- no vendor path
        return false
    end

    local minAmmoCount = (#VendorPoints + (#Waypoints - PathIndex)) * 1.5
    if Bag.GetFreeSlots() <= MIN_BAG_SLOTS or (Player:IsHunter() and Bag.GetItemCount(Hunter:GetAmmoName()) <= minAmmoCount) then
        local closestDist = 99999
        for i = 1, #VendorPoints do
            local vendorPoint = VendorPoints[i]
            if vendorPoint ~= nil then
                local dist = Player:DistanceFrom(vendorPoint[1], vendorPoint[2], vendorPoint[3])
                if dist < closestDist then
                    closestDist = dist
                    VendorPathIndex = i
                end
            end
        end

        if closestDist < 30 then
            Log.WriteLine('Vendoring!!!!!!')
            return true
        end

        Log.WriteLine('Bags full but not close enough to Vendor path [75y]. Closest = ' .. closestDist)
    end

    return false
end

Spell = ""
PauseWaypointMovTil = 0

local function PulseMovement()
    if wow.GetTime() < PauseWaypointMovTil then
        Spell = "Waiting NPC to Pass"
        Log.WriteLine("Waypoint Movement is Paused")
        Sleep(1)
        return
    end
    if STRICT_FOLLOW == true then
        MoveToNextWaypoint()
    else
        MoveToClosestWaypoint()
    end
end

AttackObject = nil

function IsTargeting(obj, tar)
    if obj == nil or tar == nil then
        return false
    end
    local unitTarget = wow.UnitTarget(obj)
    if unitTarget == nil then
        return false
    end

    return wow.UnitGUID(unitTarget) == wow.UnitGUID(tar)
end

EnemyNpcs = {}
EnemyPlayers = {}

local function ClearEnemyTables()
    for k in pairs(EnemyPlayers) do
        EnemyPlayers[k] = nil
    end
    for k in pairs(EnemyNpcs) do
        EnemyNpcs[k] = nil
    end
end

function RecoverMana()
    if Player:IsMoving() then
        wow.SendKey(83, 123) -- S
    end

    if Player:IsMoving() then
        return false
    end

    local bag, slot = Bag.GetItemPosition(Drinks)
    if not bag or not slot then
        Log.WriteLine("Unable to find a Drink to restore Mana...")
        return false
    end
    Log.WriteLine("Recovering Mana...")
    DismountCheck()
    wow.UseContainerItem(bag, slot)
    PlayerStatus = "RECOVERING"
    ClearEnemyTables()
    Sleep(2.1)
    return true
end

function RecoverHP()
    if Player:IsMoving() then
        local xx, yy, zz = Player:Position()
        Navigator.MoveTo(xx, yy, zz)
    end

    if Player:IsMoving() then
        return false
    end

    local bag, slot = Bag.GetItemPosition(Foods)
    if not bag or not slot then
        Log.WriteLine("Unable to find Food to restore HP...")
        return false
    end
    Log.WriteLine("Recovering Health...")
    DismountCheck()
    wow.UseContainerItem(bag, slot)
    PlayerStatus = "RECOVERING"
    ClearEnemyTables()
    Sleep(2.1)
    return true
end

local function MendingPet()
    if Player:IsEating() or Player:IsDrink() then
        Sleep(1.1)
        return false
    end

    if Pet:Exists() and Pet:Health() > 0 and Pet:Health() < PetMendHP then
        if Pet:Distance() < 20 and Player.IsCastable("Mend Pet") then
            if Player.IsMendingPet() then
                Log.WriteLine('Pet is being Healed!')
                Sleep(1)
            else
                Log.WriteLine('Healing Pet!!!')
                if Target:IsTargeting('pet') then
                    PetMendHP = 75
                else
                    PetMendHP = 95
                end
                Player.MendPet()
                Sleep(5.1)
            end
            return true
        end
    else
        PetMendHP = PET_MEND_HP
    end

    return false
end

RevivePetCount = 0
CallingPet = false

function ManagePet() -- True = Continue, False = Retick
    if not Player:IsHunter() or Player:HasAura("Feign Death") then
        return true
    end

    -- 召唤宝宝
    if Player:IsInCombat() then -- Res Combat
        if not Pet:Exists() and RevivePetCount < 1 then
            RevivePetCount = RevivePetCount + 1
            Player.CallPet()
        end
        return true
    end

    -- 复活或者召唤宝宝
    if (not Pet:Exists() or Pet:IsDead() or Pet:Health() <= 0) and not Player:IsCasting() and RevivePetCount < 5 then
        if not CallingPet then
            CallingPet = true
            Player.CallPet()
            Sleep(1.5)
            RevivePetCount = RevivePetCount + 1
        else
            CallingPet = false
            Player.RevivePet()
            Sleep(8)
            RevivePetCount = RevivePetCount + 1
        end
        return false
    else
        RevivePetCount = 0
    end
    if not Pet:Exists() then
        return false
    end

    -- 太远了, 就改成跟随
    if Pet:Distance() > PULL_RANGE + 1 then
        Pet.Follow()
    end

    -- Actions below should be OUT OF COMBAT
    if Player:IsInCombat() then
        return true
    end

    -- 喂食
    local happy = true
    if Pet.Happiness() ~= nil then
        happy = Pet.Happiness() > 2
    end
    if Pet.IsFeeding() and not happy then
        Sleep(2)
        Spell = "Pet Feed - WAIT"
        Log.WriteLine("Waiting for Pet Feeding Effect")
        return false
    end
    if not happy and Pet:Distance() < 10 then
        if wow.GetTime() - Player.LastFeedPetTime > 10 then -- I have an overfeeding 'bug' - probably timer ticking before feed aura is up
            for i = 1, #PetFoods, 1 do
                if Bag.Found(PetFoods[i]) then
                    Player.FeedPet(PetFoods[i])
                    Sleep(5)
                    return false
                end
            end
            Log.WriteLine("No Pet Food!")
        end
    end

    -- 加血
    if MendingPet() then
        return false
    end
end

PvpTargeted = false

local function DrinkPotion()
    if not Player:IsInCombat() or PvpTargeted then
        return false
    end

    local needHP = Player:Health() <= POT_UP_HP
    local needMana = Player:Power() <= POT_UP_MANA
    if not needHP and not needMana then
        return false
    end

    local hasMageManaGem = false
    if Player:IsMage() then
        hasMageManaGem = HasManaGem()
    end

    local items = Bag.GetItems()
    for _, itemName in ipairs(items) do
        if needHP and itemName:find("Healing Potion") and Bag.IsItemUsable(itemName) then
            Log.WriteLine('Drinking [' .. itemName .. '] for HEALTH!')
            Player.StopCast()
            Player.Use(itemName)
            return true
        end

        if needMana and (hasMageManaGem or itemName:find("Mana Potion")) then
            if hasMageManaGem and Player.IsCastable("Evocation") then
                -- we can evocate
            else
                if Bag.IsItemUsable(itemName) then
                    Log.WriteLine('Drinking [' .. itemName .. '] for MANA!')
                    Player.StopCast()
                    Player.Use(itemName)
                    return true
                end
            end
        end
    end
    return false
end

ConjureCount = 0

function Conjure()
    if not Player:IsMage() or Player.IsMounted() or Bag.GetFreeSlots() <= 1 then
        return false
    end

    if ConjureCount > 7 then -- Sit stuck
        wow.SendKey(87, 223) -- W
        ConjureCount = 0
    end

    -- 制作水喝食物
    if Bag.GetItemCount(Drinks[1]) < 12 then
        Log.WriteLine("Conjuring Water!")
        ConjureCount = ConjureCount + 1
        DismountCheck()
        Player.CastSpell("Conjure Water")
        Sleep(1)
        return true
    end
    if Bag.GetItemCount(Foods[1]) < 12 then
        Log.WriteLine("Conjuring Food!")
        ConjureCount = ConjureCount + 1
        DismountCheck()
        Player.CastSpell("Conjure Food")
        Sleep(1)
        return true
    end

    -- 制作法力宝石
    local jadeCount = Bag.GetItemCount("Mana Citrine")
    if Player.IsCastable("Conjure Mana Citrine") and jadeCount == 0 then
        Log.WriteLine("Conjuring Mana Citrine!")
        ConjureCount = ConjureCount + 1
        DismountCheck()
        Player.CastSpell("Conjure Mana Citrine")
        Sleep(1)
        return true
    elseif Player.IsCastable("Conjure Mana Jade") and jadeCount == 0 then
        Log.WriteLine("Conjuring Mana Jade!")
        ConjureCount = ConjureCount + 1
        DismountCheck()
        Player.CastSpell("Conjure Mana Jade")
        Sleep(1)
        return true
    elseif jadeCount == 0 and Player.IsCastable("Conjure Mana Agate") and Bag.GetItemCount("Mana Agate") == 0 then
        Log.WriteLine("Conjuring Mana Agate!")
        ConjureCount = ConjureCount + 1
        DismountCheck()
        Player.CastSpell("Conjure Mana Agate")
        Sleep(1)
        return true
    end
    ConjureCount = 0
end

StallBuffUp = 0

function ApplyBuff(buff)
    if Player.IsCastable(buff) == false or Player.IsMounted() == true and Player:IsCasting() and wow.GetTime() < StallBuffUp then
        return
    end
    wow.ApplyBuff(buff, "player")
    Sleep(0.5)
end

function ApplyBuffs()
    if Player:IsMage() then
        ApplyBuff("Arcane Intellect")
        if PREFER_MAGE_ARMOR then
            ApplyBuff("Mage Armor")
        else
            ApplyBuff("Ice Armor")
        end
        ApplyBuff("Ice Barrier")
    elseif Player:IsHunter() then
        ApplyBuff(HunterBuff)
    end
end

local function IsPlayerIdle()
    if Player:IsDeadOrGhost() then
        PlayerStatus = "DEAD"
        return false
    end

    if Player.IsSwimming() or Player.IsMounted() then
        return true -- 正在游泳, 或者骑行
    end

    if Player:IsEating() and Player:Health() < RECOVER_TILL_PERCENT then
        return false
    end
    if Player:IsDrinking() and Player:Power() < RECOVER_TILL_PERCENT then
        return false
    end

    -- 管理猎人宝宝
    if not ManagePet() then
        if Player:Power() < DrinkAtMana then
            RecoverMana()
            return false
        end
        return false
    end

    -- 战斗中直接退出, 以下动作无法执行
    if Player:IsInCombat() then
        return true
    end

    -- 加buff
    ApplyBuffs()

    -- 吃喝
    if Player:Health() < EatAtHP then
        RecoverHP()
        if Player:Power() < DrinkAtMana then
            RecoverMana()
        end
        return false
    end
    if Player:Power() < DrinkAtMana then
        RecoverMana()
        return false
    end
    if Player:IsEating() or Player:IsDrinking() then -- 吃喝结束
        Player.Jump() -- no longer sit
    end

    -- 法师制作水, 食物, 宝石
    if Player:IsMage() and Conjure() then
        return false
    end

    return true
end

function EnemyNearby(object)
    if DC_HORDE_NEARBY and not Player:IsInCombat() then
        if object:Distance() > 100 then
            return
        end
        if Player:Level() - object:level() > 10 then -- Harmless Enemy
            return
        end

        wow.RunMacroText(".dc")
    end
end

function AggrodToAnotherPlayer(object)
    if object:Health() == 0 or not object:HasTarget() then
        return false
    end

    if not Player:IsMage() and object:HasDebuff("Frost Nova") then
        return true
    end

    local targetingMe = object:IsTargeting("player")
    if not Player:IsHunter() then
        return (not targetingMe)
    elseif Player:IsHunter() then
        return not targetingMe and not object:IsTargeting("pet")
    end

    return false
end

function MoveFacingObject(object, div, into)
    local px, py, pz = Player:Position()
    local ox, oy, oz = object:Position()
    local dx = (px - ox) / div
    local dy = (py - oy) / div
    local dz = (pz - oz) / div
    local mx, my, mz

    if into then
        if dx < 0 then
            mx = px + math.abs(dx)
        else
            mx = px - math.abs(dx)
        end
        if dy < 0 then
            my = py + math.abs(dy)
        else
            my = py - math.abs(dy)
        end
        if dz < 0 then
            mz = pz + math.abs(dz)
        else
            mz = pz - math.abs(dz)
        end
    else
        if dx < 0 then
            mx = px - math.abs(dx)
        else
            mx = px + math.abs(dx)
        end
        if dy < 0 then
            my = py - math.abs(dy)
        else
            my = py + math.abs(dy)
        end
        if dz < 0 then
            mz = pz - math.abs(dz)
        else
            mz = pz + math.abs(dz)
        end
    end

    Navigator.MoveTo(mx, my, mz)
end

CombatTime = 0
TargetIsFar = false
AggroTable = {}

-- Holy shit this function is a mess
local function FindAttackableUnit()
    local keepAttObj = false
    -- This part is to make sure that we don't tag two different targets because incombat would be false and this function returns two diff targets 
    if AttackObject ~= nil then
        if (AttackObject:Exists() and not AttackObject:IsDead()) or (Player:IsCasting() and AttackObject:Health() > 0) then -- Keep Target --? but what if not aggrod
            if CombatTime < 3 and AttackObject:Distance() < PULL_RANGE + 3 then
                keepAttObj = true
            end
        end
    end

    -- Clear tables to choose from
    local targetTable = {}
    for k in pairs(AggroTable) do
        AggroTable[k] = nil
    end

    -- Clear out liest each scan otherwise clutter 101
    ClearEnemyTables()
    TargetIsFar = false
    PvpTargeted = false

    -- Fill target tables
    for i = 1, Object:Count() do
        local object = Object:Get(i)

        if object:IsEnemy() and not object:IsDead() then
            local ox, oy, oz = object:Position()
            local objectInfo = {ox, oy, oz, object:Level(), object:Name()}
            if object:IsPlayer() then
                EnemyNearby(object)
                table.insert(EnemyPlayers, objectInfo)
            else
                table.insert(EnemyNpcs, objectInfo)
            end
        end

        if string.find(object:Name(), "Totem") == nil and object:CanAttack() then
            local targetingMe = object:IsTargeting('player')
            if Player:IsMage() and object:HasDebuff("Frost Nova") then
                targetingMe = true
            end
            if Player:IsHunter() and object:IsTargeting('pet') then
                targetingMe = true
            end

            if targetingMe or object:Level() >= Player:Level() - LEVEL_MINUS and object:Level() <= Player:Level() + LEVEL_PLUS and object:Health() > 0 and not object:IsDead() then
                if Player:IsHunter() and object:IsPlayer() then
                    if object:IsTargeting("pet") then
                        Pet.Follow()
                    end
                end

                if not object:IsPlayer() and not Navigator.HasBarrier(Player:Location(), object:Location()) and not AggrodToAnotherPlayer(object) then
                    if object:IsInCombat() and targetingMe then -- Targetting me so auto fook him up
                        table.insert(AggroTable, object)
                    elseif not ArrayContains(AvoidNPCs, object:Name()) then -- 不是要避开的NPC
                        if not object:IsPet() then -- make sure target is not a pet of horde
                            if object:Health() > 0 and object:Health() <= 10 then
                                table.insert(AggroTable, object) -- add to aggro list for priority in killing blow
                            else
                                table.insert(targetTable, object)
                            end
                        end
                    else
                        if object:IsInAggroRange() then
                            PlayerStatus = "KITING_DANGER"
                            Log.WriteLine('Kiting Dangerous NPC - ' .. object:Name())
                            MoveFacingObject(object, 1, false) -- 0.2 so to set move far away
                            Sleep(3)
                            PauseWaypointMovTil = wow.GetTime() + 10
                        end
                    end
                else
                    if object:IsPlayer() and object:IsEnemy() and object:IsTargeting("player") then
                        PvpTargeted = true
                    end
                end
            end
        end
    end

    -- 寻找攻击目标
    local found = false
    local lowestDist = 99999
    if #AggroTable > 0 then
        -- 寻找3个pull range内, 血量最少的
        local lowestHP = 99999
        for i = 1, #AggroTable do
            local object = AggroTable[i]
            if object:Distance() < lowestDist then
                lowestDist = object:Distance()
            end
            if object:Health() < lowestHP and object:Health() > 0 then
                if object:Distance() <= PULL_RANGE * 3 then
                    lowestHP = object:Health()
                    if not keepAttObj then
                        AttackObject = object
                    end
                    found = true
                end
            end
        end
    else
        -- 寻找1个pull range范围内, 距离最近的
        for i = 1, #AggroTable do
            local object = targetTable[i]
            if object:Distance() < lowestDist and object:Health() > 0 then
                lowestDist = object:Distance()
                if object:Distance() <= PULL_RANGE then
                    if not keepAttObj then
                        AttackObject = object
                    end
                    found = true
                end
            end
        end
    end

    TargetIsFar = lowestDist > MOUNT_CUT_OFF_DIST
    return found
end

InterruptTargetGUID = nil
StopMovingBeforeAttack = true

local function HunterRotation()
    HunterBuff = "Aspect of the Hawk"
    StopMovingBeforeAttack = true
    DestX, DestY, DestZ = Target:Position()
    PlayerStatus = "ATTACK"

    local lvlDiff = Target:Level() - Player:Level()
    local ammo = Bag.GetItemCount(Hunter:GetAmmoName())

    -- Mend Pet if not being targeted
    if not Target:IsTargeting('player') then
        if MendingPet() then
            Spell = "Mending"
            return
        end
    end

    -- Movement (Kite or Melee) depending on who is targeted
    if Target:Distance() <= 12.5 or Target:Distance() > PULL_RANGE or ammo == 0 then
        if (Target:IsTargeting('player') and Target:Distance() >= 4) or (Target:Distance() > PULL_RANGE) or (ammo == 0 and Target:Distance() >= 4) then -- Move Towards mob
            Log.WriteLine('Moving into melee range.')
            local div = 3
            if ammo == 0 then
                StopMovingBeforeAttack = false
                Spell = "0 Ammo Move"
                div = 1.5
            end
            MoveFacingObject("target", div, true)
            if ammo == 0 then
                Sleep(1)
            else
                Sleep(0.5)
            end
            return
        elseif KITE_ENABLED and Target:IsTargeting('pet') and Target:Distance() < 13 and Bag.GetItemCount(Hunter:GetAmmoName()) > 0 then -- Move away to fire 
            Log.WriteLine('Moving away into kiting range [Dist:' .. Target:Distance() .. ']') -- ??confirm
            MoveFacingObject("target", 0.02, false) -- 0.2 so to set move far away
            local slp = 0.5 + ((13 - Target:Distance()) / 10);
            Sleep(slp)
            return
        end
    end

    -- 施放恐吓
    if Target:IsTargeting('player') and Target:Distance() > 6 and Player.IsCastable("Intimidation") then
        Spell = "Intimidation"
        Player.CastSpell("Intimidation")
        Sleep(0.3)
        return
    end

    -- 面向目标
    Player.FaceTarget()

    -- 施放假死
    if Player:Health() < 15 and Target:Health() > 15 and Player:IsInCombat() and Player.IsCastable("Feign Death") and not PvpTargeted then
        Spell = "Feigning Death at HP " .. Player:Health() .. " %"
        Player.CastSpell("Feign Death")
        Sleep(10)
        return
    end

    -- Range attack
    local ranged = Target:Distance() < PULL_RANGE and Target:Distance() >= 8 and ammo > 0
    if ranged then
        if not Target:HasDebuff("Hunter's Mark") then
            Spell = "Marking"
            Player.CastSpell("Hunter's Mark", false)

            if AGGRO_WITH_PET then
                Pet.Attack()
                Player.Attack()
            end

            Sleep(1)
            return
        end

        if Player:IsInCombat() and (lvlDiff > 3 or (Player:Health() < 30 and Target:Health() > 30) or #AggroTable > 1) then
            if Player.IsCastable("Rapid Fire") then
                Player.CastSpell("Rapid Fire")
                Spell = "Rapid Fire"
                return
            end
            if Player.IsCastable("Bestial Wrath") then
                Player.CastSpell("Bestial Wrath")
                Spell = "Bestial Wrath"
                return
            end
        end

        local immuneToSS = Target:Name():find("Rock") ~= nil or Target:Name():find("rock") ~= nil
        if Player:IsInCombat() and not immuneToSS and not Target:HasDebuff("Serpent Sting") then
            if Player.CastSpell("Serpent Sting", false) then
                Spell = "Serpent Sing"
                return
            end
        end

        if Player:IsInCombat() and Target:Distance() < 33 and Target:Distance() > 10 and Target:IsTargeting('player') then
            if Player.CastSpell("Concussive Shot", false) then
                Spell = "Concussing"
                return
            end
        end

        if Player:IsInCombat() and Player.CastSpell("Arcane Shot", false) then
            Spell = "Arcane Shot"
            return
        end

        -- 自动射击
        Spell = "Arrowing"
        wow.RunMacroText("/cast !Auto Shot")

        -- 自动攻击
        if AGGRO_WITH_PET then
            Pet.Attack()
            Player.Attack()
        end
    end

    -- Melee attack
    if Target:Distance() <= MELEE_RANGE then
        -- Disengage
        if not Target:IsTargeting('pet') then
            if Player.CastSpell("Disengage", false) then
                Spell = "Disengage"
                Sleep(0.2)
                return
            end
        end

        -- Mongoose bite
        if Player.CastSpell("Mongoose Bite", false) then
            Spell = "Mongoose Bite"
            Sleep(0.5)
            return
        end

        -- Blood Fury
        if (lvlDiff >= 3 or (Player:Health() < 30 and Target:Health() > 30)) and Player.IsCastable("Blood Fury") then
            Player.CastSpell("Blood Fury")
            Spell = "Blood Fury [RACIAL]"
            Sleep(1)
            return
        end

        -- Melee attack
        Spell = "MELEE RANGE"
        Pet.Attack()
        Player.Attack()

        -- Raptor strike
        if Player.CastSpell("Raptor Strike", false) then
            Spell = "Raptor Strike"
            Sleep(0.5)
            return
        end
    end
end

ForceStopNextMove = false
PrefFire = false
ForceCS = false
ForceCSAtTime = 0

local function CounterSpell()
    if ForceCS then
        local object = Obect:New(InterruptTargetGUID)
        if object == nil or object:IsDead() then
            ForceCSAtTime = 0
            ForceCS = false
        elseif object:Distance() < 32 and wow.GetTime() > ForceCSAtTime then
            if Player.IsCastable("Counterspell") then
                Spell = "Counterspell"
                Player.StopCast()
                Player.CastSpell("Counterspell", false)
                Sleep(0.333)
                ForceCSAtTime = 0
                ForceCS = false
            end
        end
    end
end

local function IsPolymorphUsed()
    for i = 1, Object:Count() do
        local object = Object:Get(i)
        if object ~= nil then
            if object:IsEnemy() and not object:IsDead() then
                if object:HasDebuff("Polymorph") then
                    return true
                end
            end
        end
    end
    return false
end

local function CanPoly(object)
    return object:Type() == "Beast" or object:Type() == "Humanoid" or object:Type() == "Critter"
end

DecurseIgnoreTill = 0

local function Decurse()
    if wow.GetTime() < DecurseIgnoreTill then
        return false
    end

    for i = 1, 40 do
        local debuff = Player.GetDebuff(i)
        if debuff == nil then
            return false
        elseif debuff:find("Curse") or debuff:find("curse") then
            Player.CastSpell("Remove Lesser Curse")
            DecurseIgnoreTill = wow.GetTime() + 10
            return true
        end
    end
end

IgnorePolyTill = 0

local function MageRotation()
    if ForceStopNextMove then -- PRECAUTION when kiting
        ForceStopNextMove = false
        wow.SendKey(83, 123) -- S
    end

    DestX, DestY, DestZ = Target:Position()
    Spell = ""
    PlayerStatus = "ATTACK"

    -- 1) 清除诅咒
    if Decurse() then
        return
    end

    -- 2) 靠近目标
    if Target:Distance() > PULL_RANGE + 1 or (Player:IsInCombat() and Target:Distance() > PULL_RANGE) then
        Log.WriteLine('Cast Distance = TOOLARGE @' .. Target:Distance())
        MoveFacingObject("target", 2, true)
        Spell = "Moving Within Range"
        Sleep(0.5)
        return
    end

    -- 3) 太远了
    if Target:Distance() >= PULL_RANGE + 5 then
        Spell = "TOO FAR"
        return
    end

    -- 4) 反制
    CounterSpell()

    -- 5) 变羊
    if #AggroTable > 1 and Player.IsCastable("Polymorph") and not IsPolymorphUsed() and wow.GetTime() > IgnorePolyTill then
        Log.WriteLine('Polymode: 1v' .. #AggroTable)
        local closest = 9999
        local polyTarget = nil
        local closestTar = nil
        local highestHP = 1
        for i = 1, #AggroTable do
            local target = AggroTable[i]
            Log.WriteLine(' --> ' .. target:Health())
            if CanPoly(target) and target:Health() > 40 then
                if target:Health() > highestHP and target:Ditance() < 30 then -- 30码内血量最高的
                    highestHP = target:Health()
                    polyTarget = target
                end
                if target:Ditance() < closest then
                    closest = target:Ditance()
                    closestTar = target
                end
            end
        end

        -- 最近的也超过了30码, 无法施放变羊
        if closestTar ~= nil and closest > 30 then
            Log.WriteLine('Moving into polymorph range as closest is' .. math.ceil(closest) .. 'y away!')
            MoveFacingObject(closestTar, 2, true)
            Sleep(0.5)
            return
        end

        -- 施放变羊
        if polyTarget ~= nil then
            Log.WriteLine('Polying Target at ' .. wow.UnitHealthPercent(polyTarget))
            Player.Target(polyTarget)
            Spell = "Polymorph"
            Player.CastSpell("Polymorph", false)
            IgnorePolyTill = wow.GetTime() + 2
            Sleep(0.3)
            return
        end
    end

    -- 6) 绷带
    if IsPolymorphUsed() and #AggroTable == 0 and Player:Health() < 70 then
        local bandage = Bag.GetBandageName()
        if bandage and Bag.IsItemUsable(bandage) then
            Log.WriteLine('Using ' .. bandage)
            Player.UserItem(bandage)
            Sleep(1.1)
            return
        end
    end

    -- 7) 唤醒
    if IsPolymorphUsed() and Player:Power() < 35 and Player.IsCastable("Evocation") then
        Player.CastSpell("Evocation")
        Sleep(4.2)
        return
    end

    -- 8.1) Kite/Blink
    if KITE_ENABLED and Target:Distance() <= 7 and Target:HasDebuff("Frost Nova") then
        MoveFacingObject("target", 0.01, false) -- 0.01 div so as to set move marker far in case tar is close
        ForceStopNextMove = true
        Spell = "Kiting"
        Sleep(0.666)
        return
    else
        -- 8.2) 唤醒
        if Player:Power() < 10 and Target:Health() > 6 and Player.IsCastable("Evocation") and not HasManaGem() then
            Player.CastSpell("Evocation")
            Spell = "Evocation"
            if Player:Health() > 75 then
                Sleep(6.1) -- almost full duration
            elseif Player:Health() > 50 then
                Sleep(4.1)
            else
                Sleep(2.1)
            end
            return
            -- 8.3) 冰盾
        elseif Player:Power() > 40 or Player:Health() < 20 then
            ApplyBuff("Ice Barrier")
            return
        end
    end

    -- 9) 冰箱
    if Player:Health() < 15 and Player:IsInCombat() and Player.IsCastable("Ice Block") then
        Spell = "Blocking at HP " .. Player:Health() .. " %"
        Player.CastSpell("Ice Block")
        Sleep(9.3)
        return
    end

    -- 10) 面向目标
    Player.FaceTarget()

    if Target:Health() > WAND_BELOW then
        -- 11.1) Cone of Cold/Nova
        if Player:IsInCombat() and Target:Distance() < 10 and not IsPolymorphUsed() then
            if Player.IsCastable("Frost Nova") then
                Spell = "Nova"
                Player.StopCast()
                Player.CastSpell("Frost Nova(Rank 1)")
                return
            end
            if Player.IsCastable("Cone of Cold") then
                Spell = "CoC"
                Player.CastSpell("Cone of Cold")
                return
            end
        end

        -- 11.2) Fire Blast
        if Player:IsInCombat() and Target:Distance() <= 19.5 and Player.IsCastable("Fire Blast") then
            Spell = "Fireblast"
            Player.CastSpell("Fire Blast", false)
            return
        end

        -- 11.3) Frostbolt / Fireball Filler
        if not PrefFire and Player.IsCastable("Frostbolt") then
            Spell = "Frostbolt"
            Player.CastSpell("Frostbolt", false)
            Sleep(0.25)
            return
        elseif Player.IsCastable("Fireball") then
            Spell = "Fireball"
            Player.CastSpell("Fireball", false)
            Sleep(0.5)
            return
        end
    else
        if Player:Health() < 20 then
            -- 12.1) Fire blast
            if Player:IsInCombat() and Target:Distance() < 20 and Player.IsCastable("Fire Blast") then
                Spell = "Fireblast LOW/CRITICAL"
                Player.CastSpell("Fire Blast", false)
                return
            end
            -- 12.2) Frost nova
            if Player:IsInCombat() and Target:Distance() < 10 and Player.IsCastable("Frost Nova") then
                Spell = "Nova LOW/CRITICAL"
                Player.StopCast()
                Player.CastSpell("Frost Nova(Rank 1)")
                return
            end
            -- 12.3) Cone of cold
            if Player:IsInCombat() and Target:Distance() < 10 and Player.IsCastable("Cone of Cold") and IsPolymorphUsed() == false then
                Spell = "CoC LOW/Critical"
                Player.StopCast()
                Player.CastSpell("Cone of Cold")
                return
            end
        end

        -- 13) 靠近目标
        if Target:Distance() > 29 then
            Spell = "Moving to Wand LOW"
            Log.WriteLine('Moving into Wanding Distance')
            MoveFacingObject("target", 8, true)
            Sleep(0.25)
            return
        end

        -- 14) 丢魔杖
        Spell = "Wanding LOW"
        Player.StopCast()
        wow.RunMacroText("/cast !Shoot")
        Sleep(1.2)
        return
    end

    -- 15) If No Mana  => WAND
    if Player:Power() < 5 then
        -- 15.1) 靠近目标
        if Target:Distance() > 29 then
            Spell = "Moving to Wand OOM"
            Log.WriteLine('Moving into Wanding Distance')
            MoveFacingObject("target", 8, true)
            Sleep(0.25)
            return
        end
        -- 15.2) 丢魔杖
        Player.StopCast()
        Spell = "Wanding OOM"
        wow.RunMacroText("/cast !Shoot")
        Sleep(1.2)
        return
    end

    -- 16) 寒冰箭
    Spell = "NOTHING"
    if not Player:IsCasting() and Target:Health() > WAND_BELOW then -- Wanding bug were isOnCD always returns true when wanding unless scripts ticks at perfect time
        if Player.IsCastable("Frostbolt") then
            Spell = "Frostbolt_NOTHING"
            Player.CastSpell("Frostbolt", false)
            Sleep(0.25)
            return
        end
    end
end

-- local autoShotOn = false
local function Attack(object)
    DrinkPotion()

    if Player:HasAura("First Aid") or (Player:IsMage() and Player:HasAura("Evocation")) then
        Sleep(0.25)
        return
    end

    if Player:HasAura("Food") or Player:HasAura("Drink") then
        Player.Jump()
    end

    if object == nil then
        return
    end

    Player.Target(object)
    if Target:IsDead() then
        return
    end

    if AggrodToAnotherPlayer("target") then
        Log.WriteLine(Target:Name() .. " at " .. Target:Health() .. " is tapped by another player...")
        Log.WriteLine(" ==> FORCING MOVEMENT");
        PulseMovement()
        PathEndCheck(RELOOP)
        return
    end

    if Player:IsMoving() and StopMovingBeforeAttack then -- Stop Movement
        wow.SendKey(83, 123) -- S
    end

    if not Target:Exists() then
        return
    end

    -- 下马
    if Player.IsMounted() then
        Player.Dismount()
    end

    -- 输出循环
    if Player:IsHunter() then
        HunterRotation()
    elseif Player:IsMage() then
        MageRotation()
    end
end

OpenArr = {false, false, false, false, false, false, false, false, false}

local function RandomAction()
    if Player:IsInCombat() then
        return
    end

    -- Reset Windows
    if OpenArr[1] then
        OpenArr[1] = false
        wow.SendKey(79) -- O
        return
    end
    if OpenArr[2] then
        OpenArr[2] = false
        wow.SendKey(74) -- J
        return
    end
    if OpenArr[3] then
        OpenArr[3] = false
        wow.SendKey(76) -- L
        return
    end
    if OpenArr[4] then
        OpenArr[4] = false
        wow.SendKey(66) -- B
        return
    end
    if OpenArr[5] then
        OpenArr[5] = false
        wow.SendKey(80) -- P
        return
    end
    if OpenArr[6] then
        OpenArr[6] = false
        wow.SendKey(67) -- C
        return
    end
    if OpenArr[7] then
        OpenArr[7] = false
        wow.SendKey(78) -- N
        return
    end

    local rnd = math.random(1, 200)
    -- Jump
    if rnd >= 1 and rnd <= 10 then
        if not Player:IsCasting() then
            Player.Jump()
        end
        -- yawn
    elseif rnd == 11 then
        wow.RunMacroText("/yawn")
        -- cheer
    elseif rnd == 12 then
        wow.RunMacroText("/cheer")
        -- train
    elseif rnd >= 13 and rnd <= 15 then
        wow.RunMacroText("/train")
    elseif rnd >= 16 and rnd <= 20 then
        wow.SendKey(79) -- O
        OpenArr[1] = true
    elseif rnd >= 21 and rnd <= 23 then
        wow.SendKey(74) -- J
        OpenArr[2] = true
    elseif rnd >= 26 and rnd <= 28 then
        wow.SendKey(76) -- L
        OpenArr[3] = true
    elseif rnd >= 31 and rnd <= 35 then
        wow.SendKey(66) -- B
        OpenArr[4] = true
    elseif rnd >= 36 and rnd <= 38 then
        wow.SendKey(80) -- P
        OpenArr[5] = true
    elseif rnd >= 39 and rnd <= 42 then
        wow.SendKey(67) -- C
        OpenArr[6] = true
    elseif rnd >= 43 and rnd <= 44 then
        wow.SendKey(78) -- N
        OpenArr[7] = true
        -- Jump
    elseif rnd > 56 and rnd < 70 then
        if not Player:IsCasting() then
            Player.Jump()
        end
    end
end

-- https://wowwiki.fandom.com/wiki/Aggro_radius
local function IsSafeToLoot(lootObject)
    if not SAFE_LOOTING then
        return true
    end

    local objCount = Object:Count()
    for i = 1, objCount do
        local object = Object:Get(i)
        if object ~= nil then
            if object:IsEnemy() and not object:IsDead() then
                local distLootAggroObj = object:DistanceFrom(lootObject)
                local aggroRad = object:Level() - Player:Level() + 25 -- suppost +20 imma to be safe +5
                if distLootAggroObj < aggroRad then
                    Log.WriteLine('Not looting ' .. lootObject:Name() .. ' as it is ' .. math.ceil(distLootAggroObj) .. 'y within hostile ' .. object:Name())
                    return false
                end
            end
        end
    end

    return true
end

PLAYER_NAME = Player:Name()
SkinningTime = 0
IgnoreSkinningTill = 0

local function Skinning()
    if not Bag.Found("Skinning Knife") then
        return false
    end
    if SkinningTime > 12 then
        Log.WriteLine("Stuck Skinning --> SKIPPING")
        SkinningTime = 0
        IgnoreSkinningTill = wow.GetTime() + 30
        return false
    end

    -- 正在剥皮, https://classic.wowhead.com/spells/name:skinning
    local spellId = wow.UnitCastID("player")
    if spellId == 10768 or spellId == 10769 or spellId == 8617 or spellId == 8613 or spellId == 8618 then -- if is skinning
        return true
    end

    if IgnoreSkinningTill > wow.GetTime() then
        return false
    end

    if Bag.GetFreeSlots() <= 0 then
        return false
    end

    local closestDist = 999999
    local skinObject = nil
    for i = 1, Object:Count() do
        local object = Object:Get(i)
        if object ~= nil then
            if object:Name() ~= "Campfire" and object:Name() ~= PLAYER_NAME and object:Name():find("Rune of") == nil then
                if object:CanBeSkinned() and not Navigator.HasBarrier(Player:Location(), object:Location()) and object:IsEnemy() then
                    if object:Distance() < closestDist and IsSafeToLoot(object) then
                        closestDist = object:Distance()
                        skinObject = object
                    end
                end
            end
        end
    end

    if skinObject ~= nil and closestDist < MAX_LOOT_DIST then
        Log.WriteLine('Skinning ' .. skinObject:Name() .. '!!!')
        Spell = skinObject:Name()

        Navigator.MoveTo(skinObject:Location())
        if skinObject:Distance() <= 5 then
            DismountCheck()
            Player.Skin(skinObject)
        end

        PlayerStatus = "SKINNING"
        ClearEnemyTables()
        if closestDist <= 3 and not Player:IsMoving() then
            SkinningTime = SkinningTime + 1.1 + PULSE_DELAY
            Sleep(1.1)
        else
            SkinningTime = SkinningTime + PULSE_DELAY
        end
        return true
    end

    SkinningTime = 0
    return false
end

LootingTime = 0
IgnoreLootingTill = 0

local function Looting()
    if Player:IsCasting() then
        return false
    end
    if Bag.GetFreeSlots() <= 0 then
        return false
    end
    if LootingTime > 6 then
        Log.WriteLine("Stuck Looting --> SKIPPING")
        LootingTime = 0
        IgnoreLootingTill = wow.GetTime() + 30
        return false
    end
    if IgnoreLootingTill > wow.GetTime() then
        return false
    end

    local closestDist = 999999
    local lootObject = nil
    local lootCount = 0
    for i = 1, Object:Count() do
        local object = Object:Get(i)
        if object ~= nil then
            if object:IsDead() and object:CanBeLooted() and not Navigator.HasBarrier(Player:Location(), object:Location()) then
                lootCount = lootCount + 1
                if object:Distance() < closestDist and IsSafeToLoot(object) then
                    closestDist = object:Distance()
                    lootObject = object
                end
            end
        end
    end

    if lootObject ~= nil and closestDist < MAX_LOOT_DIST then
        Log.WriteLine('Looting ' .. lootObject:Name() .. '!!!')
        Spell = lootObject:Name()

        Navigator.MoveTo(lootObject:Location())
        if lootObject:Distance() <= 5 then
            DismountCheck()
            Player.Loot(lootObject)
        end

        PlayerStatus = "LOOTING"
        Sleep(1)
        LootingTime = LootingTime + 0.5 + PULSE_DELAY
        return true
    end

    LootingTime = 0
    return false
end

local function DeleteRubbishItems()
    for i = 1, #DeleteItems do
        Bag.DeleteItem(DeleteItems[i][1])
    end
end

local function BuyItems()
    if Player:IsMage() then
        return
    end
    Hunter:BuyDrinks()
    Hunter:BuyAmmo()
end

SellTick = 0
CanMail = false

local function SellItems()
    Log.WriteLine('Clearing Bags...')
    for bag = 0, 4 do
        for slot = 0, Bag.GetNumSlots(bag) do
            local link = Bag.GetItemLink(bag, slot)
            if link then
                local itemName, sLink, rarity, iLevel, iMinLevel, sType, subType, iStackCount = wow.GetItemInfo(link)
                if ArrayContains(ForcedToSell, itemName) then
                    Log.WriteLine('Force-Selling: ' .. itemName)
                    Bag.SellItem(bag, slot)

                elseif Player:IsHunter() and (itemName == Hunter:GetAmmoName() or ArrayContains(PetFoods, itemName)) then
                    -- DbgPrint('Keeping [Hunter Ammo/PetFood]: '..sName)
                elseif subType == "Bag" or (Player:IsHunter() and (subType == "Quiver" or subType == "Ammo Pouch")) then
                    -- Bug where last Bag is perceived as item in other bags for selling :/
                elseif itemName:find("Potion") ~= nil or itemName:find("Bandage") ~= nil then
                    -- DbgPrint('Keeping [Potion]: '..sName)
                elseif itemName == "Hearthstone" or sType == "Projectile" or rarity >= 3 then
                    -- DbgPrint('Keeping [HardCoded]: '..sName)
                elseif rarity >= 2 then -- and (sSubType == "Bows" or sSubType == "Guns" or sSubType == "Two-Handed Swords" or sSubType == "Leather") then
                    -- DbgPrint('Keeping [Rarity]: '..sName)
                elseif ArrayContains(ToKeep, itemName) or ArrayContains(ToMail, itemName) then
                    -- DbgPrint('Keeping [ToKeepList]: '..sName)
                elseif itemName == MOUNT_NAME then
                    -- DbgPrint('Keeping [Mount]: '..sName)
                elseif ArrayContains(Foods, itemName) or ArrayContains(Drinks, itemName) then
                    -- DbgPrint('Keeping [RegenConsumable]: '..sName)
                else
                    if MAIL_ENABLED and rarity < 1 then -- since we are mailing, just sell junk
                        Log.WriteLine('Selling [Junk]: ' .. itemName)
                        Bag.SellItem(bag, slot)
                    else
                        if not MAIL_ENABLED then -- since we are not mailing sell junk + whites
                            Log.WriteLine('Selling [Space]: ' .. itemName)
                            Bag.SellItem(bag, slot)
                        end
                    end
                end
            end
        end
    end
end

local function SellBuyRepair()
    DeleteRubbishItems()

    -- Talk To Vendor
    if not TalkedToVendor then
        for i = 1, Object:Count() do
            local object = Object:Get(i)
            if object:Name() == VendorName then
                Log.WriteLine('Selling to ' .. VendorName)
                wow.InteractUnit(VendorName)
                Sleep(1.5)
            end
        end
        -- merchant_show event will handle this
        return
    else
        SellItems()
        BuyItems()
        if Merchant.CanRepair() then
            Merchant.Repair()
        end

        VendorPathIndex = #VendorPoints - 1
        SellTick = SellTick + 1
        if SellTick == 5 then
            SellComplete = true
            CanMail = true
            SellTick = 0
        end
        Sleep(6)
    end
end

LibDraw = LibStub("LibDraw-1.0")
LibDraw.SetWidth(30)

local function ResetVariables()
    Log.WriteLine("Resetting Vars!!!")
    GoingToVendor = false
    AtVendor = false
    SellComplete = false
    TalkedToVendor = false
    AtStartAfterVendor = false
end

DebugMessage = ""

local function DrawMainLine()
    if DestX ~= nil and DestY ~= nil and DestZ ~= nil then
        local pX, pY, pZ = Player:Position()
        LibDraw.SetColorRaw(0, 0, 1, 1)
        LibDraw.Line(pX, pY, pZ + 0.2, DestX, DestY, DestZ + 0.2)
    end
end

local function MarkEnemyNpcs()
    if #EnemyNpcs == 0 then
        return
    end
    LibDraw.SetColorRaw(1, 1, 1, 1)
    for i = 1, #EnemyNpcs do
        local enemyNpc = EnemyNpcs[i]
        LibDraw.Text('[' .. enemyNpc[4] .. ']', "GameFontRedSmall", enemyNpc[1], enemyNpc[2], enemyNpc[3] + 2)
    end
end

local function MarkEnemyPlayers()
    if #EnemyPlayers == 0 then
        return
    end
    for i = 1, #EnemyPlayers do
        local enemyPlayer = EnemyPlayers[i]
        local enemyLevel = enemyPlayer[4]
        if enemyLevel == nil then
            enemyLevel = 60
        end
        local levelDiff = enemyLevel - Player:Level()
        if levelDiff > 0 then
            LibDraw.SetColorRaw(1, 0, 0, 1)
            LibDraw.Text('ENEMY {+' .. levelDiff .. '}', "GameFontNormal", enemyPlayer[1], enemyPlayer[2], enemyPlayer[3] + 2)
        else
            LibDraw.SetColorRaw(1, 0.65, 0, 1)
            LibDraw.Text('ENEMY {' .. levelDiff .. '}', "GameFontNormal", enemyPlayer[1], enemyPlayer[2], enemyPlayer[3] + 2)
        end
    end
end

local function DrawDebugMessage()
    if DebugMessage == "" then
        return
    end
    local pX, pY, pZ = Player:Position()
    local debugMessage = DebugMessage
    if Spell ~= "" and PlayerStatus == "ATTACK" or PlayerStatus == "SKINNING" then
        debugMessage = debugMessage .. " [" .. Spell .. "]"
    end
    LibDraw.SetColorRaw(0, 0, 1, 1)
    LibDraw.Text(debugMessage, "GameFontRedSmall", pX, pY, pZ + 4)
end

local function DrawStatus()
    LibDraw.SetColorRaw(1, 1, 1, 1)
    local pX, pY, pZ = Player:Position()
    if PlayerStatus == "ATTACK" then -- Attacking
        local attackStatus = 'Attacking...'
        if AttackObject ~= nil then
            local odist = Player:DistanceFrom(AttackObject)
            attackStatus = wow.ObjectName(AttackObject) .. ' [' .. wow.UnitHealthPercent(AttackObject) .. '%] {' .. math.ceil(odist) .. 'y}'
        end
        LibDraw.Text(attackStatus, "GameFontNormal", pX, pY, pZ + 3)

    elseif PlayerStatus == "WAYPOINT" then -- Searching mobs
        LibDraw.Text('Searching Mobs...', "GameFontNormal", pX, pY, pZ + 3)

    elseif PlayerStatus == "RECOVERING" then -- Recovering
        LibDraw.Text('Recovering...', "GameFontNormal", pX, pY, pZ + 3)

    elseif PlayerStatus == "LOOTING" then -- Looting
        LibDraw.Text('Looting...', "GameFontNormal", pX, pY, pZ + 3)

    elseif PlayerStatus == "SKINNING" then -- Skinning
        LibDraw.Text('Skinning...', "GameFontNormal", pX, pY, pZ + 3)

    elseif PlayerStatus == "CORPSE_RUN" then -- Corpse run
        LibDraw.Text('Corpse Run...', "GameFontNormal", pX, pY, pZ + 3)

    elseif PlayerStatus == "VENDOR" then -- Vender
        if SellComplete then
            LibDraw.Text('Going to Start...', "GameFontNormal", pX, pY, pZ + 3)
        else
            LibDraw.Text('Going to Sell...', "GameFontNormal", pX, pY, pZ + 3)
        end

    elseif PlayerStatus == "DEAD" then -- Dead
        LibDraw.SetColorRaw(1, 0, 0, 1)
        LibDraw.Text('DEAD!!!', "GameFontNormal", pX, pY, pZ + 3)

    elseif PlayerStatus == "KITING_DANGER" then -- Avoiding dangerous NPC
        LibDraw.SetColorRaw(1, 0, 0, 1)
        LibDraw.Text('Avoiding Dangerous NPC!!!', "GameFontNormal", pX, pY, pZ + 3)
    end
end

local function DrawWaypoints()
    if #Waypoints == 0 then
        return
    end
    LibDraw.SetColorRaw(0, 1, 0, 1)
    local beforePoint = nil
    for i = 1, #Waypoints do
        local newPoint = Waypoints[i]
        if newPoint ~= nil then
            if beforePoint ~= nil then
                LibDraw.Line(beforePoint[1], beforePoint[2], beforePoint[3], newPoint[1], newPoint[2], newPoint[3])
            end
            beforePoint = newPoint
        end
    end
end

local function DrawVendorPoints()
    if #VendorPoints == 0 then
        return
    end
    local startPoint = VendorPoints[1]
    local endPoint = VendorPoints[#VendorPoints]
    if startPoint ~= nil then
        -- 标记起点和终点
        LibDraw.SetColorRaw(0.25, 0.5, 0.75, 1)
        LibDraw.Circle(startPoint[1], startPoint[2], startPoint[3], 2)
        LibDraw.Text('Vendor Route', "GameFontRedSmall", startPoint[1], startPoint[2], startPoint[3] + 1)
        LibDraw.Text('Vendor', "GameFontRedSmall", endPoint[1], endPoint[2], endPoint[3] + 1)

        -- 中间各点
        local beforePoint = nil
        LibDraw.SetColorRaw(1, 1, 1, 1)
        for i = 1, #VendorPoints do
            local newPoint = VendorPoints[i]
            if newPoint ~= nil then
                if beforePoint ~= nil then
                    LibDraw.Line(beforePoint[1], beforePoint[2], beforePoint[3], newPoint[1], newPoint[2], newPoint[3])
                end
                beforePoint = newPoint
            end
        end
    end
end

-- 打开箱子, 蚌壳等物品, 具体哪些物品在OpenInBags中定义
local function OpenBoxItems()
    for bag = 0, 4 do
        for slot = 0, Bag.GetNumSlots(bag) do
            local itemName = Bag.GetItemName(bag, slot)
            if ArrayContains(OpenInBags, itemName) then
                Log.WriteLine("Opening " .. itemName)
                Bag.UseItem(bag, slot)
            end
        end
    end
end

local function IsPlayerFoccussed()
    local bKawardCheck = true
    for i = 1, Object:Count() do
        local object = Object:Get(i)
        if not object:IsDead() and not object:IsPlayer() then
            local focussed = object:IsTargeting('player')
            if not focussed and Player:IsHunter() then
                focussed = object:IsTargeting('pet')
            end
            if object:IsInCombat() and object:CanAttack() then
                if focussed or (Player:IsMage() and object:HasDebuff("Frost Nova")) then -- Unit stops targetting when nova'd
                    return true
                else
                    if bKawardCheck then -- Some kaward mobs stop targetting you despite having 'aggro'
                        if object:Health() <= 10 then
                            return true
                        end
                    end
                end
            end
        end
    end

    return false
end

MountTries = 0
MountTimeout = 0

local function TryMountUp()
    if MountTimeout > wow.GetTime() then
        return false -- do not mount (indoor bug)
    end

    if MountTries >= 3 then
        MountTries = 0
        MountTimeout = wow.GetTime() + 5
    end

    if Player.IsIndoors() and not Player:IsInCombat() then
        MountTries = 0
        return false -- do not mount
    end

    if not Player:IsInCombat() and not Player.IsMounted() and not Player.IsIndoors() and HasMount() then
        if Player:IsMoving() then
            wow.SendKey(83, 222) -- S
        end
        Player.Use(MOUNT_NAME)
        StallBuffUp = wow.GetTime() + 8
        MountTries = MountTries + 1
        Sleep(1)
        return true
    end

    MountTries = 0
    return false
end

Ttt = wow.GetTime()
TttTick = 10

function IsNotVendorPathing()
    return not GoingToVendor and not AtVendor and not SellComplete and not TalkedToVendor and not AtStartAfterVendor
end

local function ResurrectPulse()
    for i = 1, Object:Count() do
        local object = Object:Get(i)
        if object:IsCorpse() and object:Name() == Player:Name() and object:Distance() < 35 then
            if Player.CorpseRecoveryDelay() <= 0 then
                if PositionAggroCount() >= 1 then
                    Sleep(5)
                    return false
                end
                Player.RetrieveCorpse()
                return true
            else
                Sleep(5)
                return true
            end
        end
    end

    return false
end

-- OnUpdate
DeadTime = 0

local function onUpdate(...)
    if ReadyToDraw() then -- every 50 ms
        LibDraw.clearCanvas()
        MarkEnemyPlayers()
        MarkEnemyNpcs()
        DrawMainLine()
        DrawWaypoints()
        DrawVendorPoints()
        DrawDebugMessage()
        DrawStatus()
    end

    if not ReadyToPulse() then    -- every 250 ms
        return
    end

    if Player:IsDead() then
        Log.WriteLine('Player dead at time: ' .. wow.GetTime())
        if Player:IsDeadOrGhost() then
            Log.WriteLine("Running Resurrect Script")
            wow.RunMacroText(wow.ReadFile('Resurrect.lua'))
            Exit('Resurrect')
        end
    end

    -- Resurrect
    if Player:IsDeadOrGhost() then
        if DeadTime > 600 then
            Log.WriteLine('Stuck Dead!')
            wow.RunMacroText(".dc")
        end
        PlayerStatus = "CORPSE_RUN"
        DeadTime = DeadTime + PULSE_DELAY
        if not ResurrectPulse() then
            PulseMovement()
            PathEndCheck(RELOOP)
        end
        return
    else
        DeadTime = 0
    end

    -- Main
    if IsPlayerIdle() then
        DebugMessage = "VITALS_OK"

        if Player:IsInCombat() and CombatTime < 90 and (CLEAR_VENDOR_PATH or (not CLEAR_VENDOR_PATH and not Player.IsMounted() and IsNotVendorPathing())) then
            -- Without this it will go too HAM because of InCombat remains a bit after fight ends w/o time to recover			
            -- ATTACK_1
            if IsPlayerFoccussed() or (Player:IsMage() and IsPolymorphUsed()) then
                DebugMessage = "ATTACK_1"
                FindAttackableUnit()
                Attack(AttackObject)
            end
            CombatTime = CombatTime + (NextPulseTime - wow.GetTime())
        else
            -- 没十秒多执行一次?
            if wow.GetTime() - Ttt > TttTick then
                -- 装备红了?
                if DC_ON_ITEM_BREAK and Player.GetLowestDurability() <= 1 then
                    Log.WriteLine('Item Break...')
                    wow.RunMacroText(".dc")
                end

                DebugMessage = "10s_TIMER_TICK"
                OpenBoxItems()
                if not AtVendor and not SellComplete and not TalkedToVendor and not AtStartAfterVendor then
                    DeleteRubbishItems()
                    RandomAction()
                end
                Ttt = wow.GetTime()
                TttTick = math.random(10, 20)
            end
            CombatTime = 0

            if not GoingToVendor then
                GoingToVendor = EmptyBagsSetup()
            end

            if GoingToVendor and not AtVendor then -- 跑向vendor中
                if CLEAR_VENDOR_PATH and FindAttackableUnit() then
                    DebugMessage = "TO_VENDOR_ATTACKING"
                    Attack(AttackObject)
                else
                    -- MountUp just checks if it needs to Mount, if not (walking or already mounted) WILL RETURN FALSE
                    if not TryMountUp() then
                        DebugMessage = "VENDOR_PATH"
                        if LOOT_ON_VENDOR_PATH == false then
                            VendorPath(true)
                        else
                            if not Skinning() and not Looting() then
                                VendorPath(true)
                            end
                        end
                    end
                end
            elseif AtVendor and not SellComplete then -- 开始卖东西
                DebugMessage = "Selling, buying, repairing"
                SellBuyRepair()
            elseif SellComplete and not AtStartAfterVendor then -- 邮寄东西
                if MAIL_ENABLED and CanMail then
                    Log.WriteLine("Running Mail Script!")
                    wow.RunMacroText(wow.ReadFile('Mail.lua'))
                    Exit('Mail')
                end

                if CLEAR_VENDOR_PATH and FindAttackableUnit() then
                    DebugMessage = "TO_START_ATTACKING"
                    Attack(AttackObject)
                else
                    if not TryMountUp() then
                        DebugMessage = "START_PATH"
                        if LOOT_ON_VENDOR_PATH == false then
                            VendorPath(false)
                        else
                            if not Skinning() and not Looting() then
                                VendorPath(false)
                            end
                        end
                    end
                end
            elseif AtStartAfterVendor then -- 卖完东西, 返回到原点
                ResetVariables()
            else
                if not Skinning() and not Looting() then
                    DebugMessage = "NOT_SKIN/LOOT-ING"
                    if FindAttackableUnit() then
                        DebugMessage = "ATTACK_2"
                        Attack(AttackObject)
                    else
                        local castingID = wow.UnitCastID("player")
                        if castingID ~= 0 and not Player:IsInCombat() then -- Mage problem
                            DebugMessage = "PREVENTING_MAGE_CAST_INTERR"
                        else
                            if TargetIsFar and MOUNT_WHILE_GRINDING and not Player.IsIndoors() and not Player.IsMounted() and HasMount() then
                                if TryMountUp() then
                                    DebugMessage = "MOUNTING_TO_NEXT_TARGET"
                                    Log.WriteLine('Target is far away... Mounting!')
                                end
                            else
                                DebugMessage = "MOVEMENT_LAST"
                                PulseMovement()
                                PathEndCheck(RELOOP)
                            end
                        end
                    end
                else
                    DebugMessage = "LOOTING_SKINNING"
                    SetIndexToClosest(true, 10)
                end
            end
        end
    else
        if #AvoidNPCs > 0 then
            FindAttackableUnit() -- still need to avoid dangerous NPCs
        end
        DebugMessage = "VITALS_FAILED"
    end

    -- 卡住了
    if StuckTime > 90 or CombatTime > 120 then
        Log.WriteLine('Bot is stuck at idx ' .. PathIndex)
        wow.RunMacroText(".dc")
        Exit("Stuck")
    end
end

Frame:RegisterEvent("COMBAT_LOG_EVENT_UNFILTERED")
Frame:RegisterEvent("MERCHANT_SHOW")

Frame:SetScript("OnEvent", function(self, event)
    -- 打开商人窗口
    if event == "MERCHANT_SHOW" then
        TalkedToVendor = true
        Log.WriteLine("Vendor Window Open!!!")
        -- 战斗信息
    elseif event == "COMBAT_LOG_EVENT_UNFILTERED" and Player:IsInCombat() then
        local timestamp, subevent, _, sourceGUID, sourceName, sourceFlags, sourceRaidFlags, destGUID, destName, destFlags, destRaidFlags = wow.CombatLogGetCurrentEventInfo()
        -- 开始施法
        if subevent == "SPELL_CAST_START" then
            local object = wow.GetObjectWithGUID(sourceGUID)
            if not AggrodToAnotherPlayer(object) then
                InterruptTargetGUID = sourceGUID
                if Player:IsMage() then
                    ForceCS = true
                    ForceCSAtTime = wow.GetTime() + CS_DELAY
                end
            end
        end
    end
end)

-- 插件命令
SLASH_LYNX_START1 = "/lynx-start"
SLASH_LYNX_STOP1 = "/lynx-stop"
SLASH_LYNX_TEST1 = "/lynx-test"

SlashCmdList["LYNX_START"] = function()
    Log.WriteLine("Lynx start!")
    Frame:SetScript("OnUpdate", onUpdate)
end

SlashCmdList["LYNX_STOP"] = function()
    Log.WriteLine("Lynx stop!")
    Frame:SetScript("OnUpdate", nil)
end

SlashCmdList["LYNX_TEST"] = function()
end
