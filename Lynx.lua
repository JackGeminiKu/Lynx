-- Hunter
Hunter = {}
function Hunter:GetAmmoName()
    local level = Wow.UnitLevel("player")
    if level >= 55 then
        return "Wicked Arrow"
    elseif level >= 40 then
        return "Jagged Arrow"
    elseif level >= 25 then
        return "Razor Arrow"
    elseif level >= 15 then
        return "Sharp Arrow"
    else
        return "Rough Arrow"
    end
end

function Hunter:GetAmmoMaxCount()
    return 3000
end

function Hunter:BuyAmmo()
    if Wow.IsHunter() == false then
        return
    end

    local vendorSlot = GetVendorSlot(self:GetAmmoName())
    if vendorSlot == -1 then
        return
    end

    local ammoCount = Wow.GetItemCount(self:GetAmmoName())
    local needToBuy = self:GetAmmoMaxCount() - ammoCount;
    if needToBuy < 200 then
        return
    end

    Wow.DebugPrint('Buying ' .. needToBuy .. ' ' .. self:GetAmmoName());
    local div = needToBuy / 200
    for i = 1, div do
        Wow.BuyMerchantItem(vendorSlot);
    end

    Sleep(1) -- ammo takes a ton of time to appear
end

-- CHECK FOR --REMOVE for other zones
--------------------FILE STUFF--------------------
RESURRECT_ENABLED = true -- MAKE SURE YOU WRITE MAIL.LUA
MAIL_ENABLED = false -- NO MAIL!

-- Keep drink 2 for hunter buy!
Drinks = {"Conjured Fresh Water", "Conjured Sparkling Water", "Sweet Nectar", "Ice Cold Milk", "Melon Juice"}
Foods = {"Conjured Muffin", "Conjured Sourdough", "Wild Hog Shank", "Mutton Chop", "Cured Ham Steak"}

--------------------CLASS SPECIFIC--------------------
PetFoods = {"Haunch of Meat", "Big Bear Meat", "Turtle Meat", "Mutton Chop", "Wild Hog Shank", "Red Wolf Meat"}
PET_MEND_HP = 25 -- Heal pet at this HP
PetMendHP = PET_MEND_HP
HunterBuff = "Aspect of the Hawk"
AGGRO_WITH_PET = false -- Hunter tags and pet only goes in if in melee range

PREFER_MAGE_ARMOR = false
WAND_BELOW = 1 -- wand below X%
CS_DELAY = math.random(0.9, 1.2)

--------------------GENERAL--------------------
MOUNT_NAME = "Brown Horse Bridle"

AvoidNPCs = {"Scorched Guardian", "Teremus the Devourer", "Servant of Grol", "Boss Tho'gun", "Anathemus", "Dustbelcher Mystic", "Dustbelcher Shaman", "Dustbelcher Wyrmhunter", "Dustbelcher Mauler"}
ToMail = {"Mageweave Cloth", "Runecloth", "Silk Cloth", "Wool Cloth", "Rugged Leather", "Thick Leather", "Felcloth", "Mageweave Cloth", "Demonic Rune"} -- Can leave empty if mailing
ForcedToSell = {"Citrine"}
OpenInBags = {"Thick-shelled Clam"}
ToKeep = {"Brown Horse Bridle", "Skinning Knife", "Strong Fishing Pole", "Fishing Pole", "Rune of Teleportation", "Rune of Portals"}

Waypoints = { --
    [1] = {3900.4057617188, -878.15447998047, 277.8918762207},
    [2] = {3897.9526367188, -873.376953125, 278.96032714844},
    [3] = {3894.9252929688, -868.85729980469, 280.11065673828},
    [4] = {3891.5666503906, -864.20245361328, 281.08041381836},
    [5] = {3888.1574707031, -859.88012695313, 281.80163574219},
    [6] = {3884.4685058594, -855.78179931641, 282.61917114258},
    [7] = {3880.0959472656, -851.98004150391, 283.76119995117},
    [8] = {3875.3833007813, -848.68823242188, 284.81030273438},
    [9] = {3870.7502441406, -845.54388427734, 285.98251342773},
    [10] = {3866.1181640625, -842.65393066406, 287.04534912109},
    [11] = {3861.3842773438, -839.65942382813, 287.46258544922},
    [12] = {3856.9855957031, -836.68267822266, 287.53442382813},
    [13] = {3852.5476074219, -833.67059326172, 288.20452880859},
    [14] = {3847.5446777344, -830.27520751953, 288.79516601563},
    [15] = {3843.0012207031, -827.81237792969, 289.44387817383},
    [16] = {3838.0163574219, -825.16949462891, 290.74725341797},
    [17] = {3833.5275878906, -822.12298583984, 292.15951538086},
    [18] = {3828.6774902344, -818.927734375, 293.4382019043},
    [19] = {3823.3073730469, -816.30944824219, 295.14202880859},
    [20] = {3819.1806640625, -812.81884765625, 296.80813598633},
    [21] = {3814.3149414063, -810.26977539063, 298.83087158203},
    [22] = {3811.3552246094, -805.70239257813, 300.67501831055},
    [23] = {3806.4106445313, -803.75592041016, 303.22235107422},
    [24] = {3801.2937011719, -806.02081298828, 304.76080322266},
    [25] = {3796.4243164063, -809.18969726563, 307.87817382813},
    [26] = {3791.8322753906, -812.12579345703, 307.72457885742},
    [27] = {3787.162109375, -815.0048828125, 308.17434692383},
    [28] = {3783.3525390625, -818.66851806641, 308.97760009766},
    [29] = {3778.5771484375, -822.55590820313, 309.50183105469},
    [30] = {3774.0817871094, -825.40185546875, 310.00628662109},
    [31] = {3768.4790039063, -827.31469726563, 310.75393676758},
    [32] = {3762.9462890625, -829.06396484375, 311.15771484375},
    [33] = {3757.3303222656, -830.20581054688, 311.87380981445},
    [34] = {3752.2668457031, -832.27734375, 311.76300048828},
    [35] = {3746.9670410156, -833.1923828125, 312.26992797852},
    [36] = {3743.9216308594, -828.61437988281, 315.02047729492},
    [37] = {3749.099609375, -827.39074707031, 314.14202880859},
    [38] = {3754.1716308594, -825.17260742188, 313.64422607422},
    [39] = {3759.0671386719, -822.96826171875, 313.05612182617},
    [40] = {3764.2993164063, -820.92504882813, 313.44543457031},
    [41] = {3769.4560546875, -819.18225097656, 313.29846191406},
    [42] = {3774.8012695313, -817.23876953125, 312.47103881836},
    [43] = {3779.9582519531, -815.91015625, 310.8258972168},
    [44] = {3785.1811523438, -814.62042236328, 309.26327514648},
    [45] = {3790.3676757813, -812.40753173828, 308.00384521484},
    [46] = {3795.0598144531, -809.52111816406, 308.0085144043},
    [47] = {3799.669921875, -806.25042724609, 305.71697998047},
    [48] = {3804.1376953125, -803.02178955078, 304.40341186523},
    [49] = {3808.4978027344, -799.69201660156, 304.06625366211},
    [50] = {3812.7028808594, -795.91412353516, 304.65972900391},
    [51] = {3816.6657714844, -791.99914550781, 305.76983642578},
    [52] = {3820.5927734375, -788.40014648438, 306.98291015625},
    [53] = {3824.8220214844, -784.99566650391, 308.29040527344},
    [54] = {3829.5385742188, -781.57250976563, 309.80212402344},
    [55] = {3834.3562011719, -778.94287109375, 310.53704833984},
    [56] = {3839.3132324219, -776.86010742188, 310.67474365234},
    [57] = {3844.7099609375, -775.33392333984, 310.54931640625},
    [58] = {3850.2839355469, -773.89611816406, 311.38360595703},
    [59] = {3855.6281738281, -772.86187744141, 312.53564453125},
    [60] = {3861.3935546875, -772.01428222656, 313.13220214844},
    [61] = {3866.9372558594, -770.95709228516, 312.79870605469},
    [62] = {3872.6784667969, -770.08135986328, 312.07363891602},
    [63] = {3878.0864257813, -769.33221435547, 311.6682434082},
    [64] = {3883.1596679688, -770.35626220703, 311.67404174805},
    [65] = {3889.0517578125, -770.09063720703, 312.39990234375},
    [66] = {3891.3852539063, -764.31420898438, 312.69204711914},
    [67] = {3885.80078125, -764.44207763672, 311.88873291016},
    [68] = {3880.0246582031, -764.87744140625, 311.80612182617},
    [69] = {3874.4929199219, -765.29443359375, 312.07733154297},
    [70] = {3868.9350585938, -765.71337890625, 312.45016479492},
    [71] = {3863.6125488281, -766.11456298828, 312.69836425781},
    [72] = {3857.6342773438, -766.62951660156, 312.55944824219},
    [73] = {3852.1701660156, -768.20294189453, 312.18975830078},
    [74] = {3846.9643554688, -769.33270263672, 312.08215332031},
    [75] = {3841.5947265625, -770.16497802734, 312.29699707031},
    [76] = {3836.0871582031, -771.02044677734, 312.17437744141},
    [77] = {3830.9362792969, -771.88110351563, 312.02697753906},
    [78] = {3825.5310058594, -772.34576416016, 312.32336425781},
    [79] = {3820.4184570313, -770.14630126953, 313.66595458984},
    [80] = {3819.5561523438, -764.84234619141, 315.60629272461},
    [81] = {3819.6013183594, -759.50531005859, 317.43103027344},
    [82] = {3820.232421875, -753.68023681641, 319.28973388672},
    [83] = {3822.15234375, -748.52209472656, 320.6257019043},
    [84] = {3824.0297851563, -743.60064697266, 321.55737304688},
    [85] = {3826.0712890625, -737.91882324219, 322.12237548828},
    [86] = {3827.953125, -732.681640625, 322.51211547852},
    [87] = {3831.2160644531, -728.17523193359, 323.02102661133},
    [88] = {3833.9792480469, -723.52819824219, 324.43890380859},
    [89] = {3836.6987304688, -718.59381103516, 325.27847290039},
    [90] = {3838.8977050781, -712.91302490234, 325.65661621094},
    [91] = {3841.3771972656, -708.09869384766, 325.76095581055},
    [92] = {3843.2736816406, -702.82037353516, 325.86730957031},
    [93] = {3845.2651367188, -697.27850341797, 325.73693847656},
    [94] = {3847.2492675781, -691.75659179688, 326.13900756836},
    [95] = {3849.2229003906, -686.26416015625, 326.76440429688},
    [96] = {3851.1235351563, -681.22479248047, 327.42443847656},
    [97] = {3851.9775390625, -676.05407714844, 328.30917358398},
    [98] = {3855.0942382813, -671.29089355469, 329.15823364258},
    [99] = {3858.9309082031, -667.04290771484, 330.13702392578},
    [100] = {3863.2644042969, -663.95758056641, 330.66220092773},
    [101] = {3868.0227050781, -668.66174316406, 329.30834960938},
    [102] = {3873.53515625, -667.42462158203, 329.50802612305},
    [103] = {3878.0515136719, -664.30804443359, 330.24487304688},
    [104] = {3880.1843261719, -659.30047607422, 331.61697387695},
    [105] = {3883.2939453125, -654.55578613281, 333.05981445313},
    [106] = {3887.3830566406, -651.18322753906, 333.74557495117},
    [107] = {3891.23828125, -646.423828125, 334.82067871094},
    [108] = {3894.7631835938, -641.7294921875, 336.27960205078},
    [109] = {3898.23046875, -636.95892333984, 336.78570556641},
    [110] = {3901.4267578125, -632.55389404297, 336.63973999023},
    [111] = {3904.9099121094, -627.82781982422, 336.49658203125},
    [112] = {3908.7648925781, -623.80151367188, 337.06600952148},
    [113] = {3912.7756347656, -620.20196533203, 338.34588623047},
    [114] = {3917.3601074219, -616.56683349609, 340.37231445313},
    [115] = {3922.3645019531, -613.57043457031, 341.3044128418},
    [116] = {3927.4645996094, -611.03503417969, 341.05926513672},
    [117] = {3932.6330566406, -609.40026855469, 340.6315612793},
    [118] = {3938.0827636719, -608.11102294922, 341.10919189453},
    [119] = {3944.1198730469, -606.68273925781, 341.07672119141},
    [120] = {3949.7822265625, -605.34307861328, 339.82833862305},
    [121] = {3955.1892089844, -604.06384277344, 338.64910888672},
    [122] = {3960.7351074219, -602.72613525391, 338.53280639648},
    [123] = {3966.1286621094, -601.39099121094, 338.5537109375},
    [124] = {3971.5095214844, -600.90795898438, 337.91943359375},
    [125] = {3972.6413574219, -607.6962890625, 336.67431640625},
    [126] = {3967.6665039063, -609.67889404297, 337.02932739258},
    [127] = {3962.0466308594, -610.35833740234, 337.63613891602},
    [128] = {3956.0825195313, -611.49774169922, 338.05560302734},
    [129] = {3950.5661621094, -612.40661621094, 338.83987426758},
    [130] = {3944.7607421875, -613.28314208984, 339.68988037109},
    [131] = {3939.3012695313, -614.107421875, 339.61148071289},
    [132] = {3934.0927734375, -614.89379882813, 339.3274230957},
    [133] = {3928.7150878906, -616.07073974609, 339.63708496094},
    [134] = {3923.8408203125, -618.46319580078, 340.00659179688},
    [135] = {3918.845703125, -621.8251953125, 339.13784790039},
    [136] = {3914.5246582031, -625.45251464844, 337.36514282227},
    [137] = {3910.9145507813, -629.85186767578, 336.19421386719},
    [138] = {3906.2072753906, -632.19451904297, 336.15798950195},
    [139] = {3901.5300292969, -635.15472412109, 336.63110351563},
    [140] = {3898.5466308594, -639.98895263672, 336.52658081055},
    [141] = {3895.1062011719, -644.53985595703, 335.45138549805},
    [142] = {3891.3439941406, -649.51647949219, 333.85528564453},
    [143] = {3887.5732421875, -653.50720214844, 333.02847290039},
    [144] = {3883.2116699219, -657.94348144531, 332.00570678711},
    [145] = {3879.4267578125, -661.79321289063, 330.93185424805},
    [146] = {3875.0773925781, -666.21697998047, 329.74014282227},
    [147] = {3871.2299804688, -670.14044189453, 329.07760620117},
    [148] = {3867.71484375, -674.13092041016, 328.7033996582},
    [149] = {3864.1589355469, -678.400390625, 328.1725769043},
    [150] = {3860.6928710938, -682.56225585938, 327.39825439453},
    [151] = {3857.1594238281, -686.80487060547, 326.49468994141},
    [152] = {3853.603515625, -691.07434082031, 325.73348999023},
    [153] = {3850.1430664063, -695.2294921875, 325.38928222656},
    [154] = {3846.4050292969, -699.72277832031, 325.68063354492},
    [155] = {3844.1853027344, -704.73498535156, 325.75628662109},
    [156] = {3842.51171875, -709.99920654297, 325.56378173828},
    [157] = {3840.400390625, -714.93951416016, 325.36834716797},
    [158] = {3838.248046875, -719.97637939453, 324.93106079102},
    [159] = {3835.8857421875, -725.50402832031, 323.58203125},
    [160] = {3833.5751953125, -730.91101074219, 321.9089050293},
    [161] = {3831.4055175781, -735.98809814453, 321.2453918457},
    [162] = {3829.1809082031, -741.19396972656, 320.89569091797},
    [163] = {3827.0456542969, -746.19055175781, 320.33087158203},
    [164] = {3825.4689941406, -751.52557373047, 319.04516601563},
    [165] = {3824.4138183594, -756.75738525391, 317.51599121094},
    [166] = {3823.599609375, -762.14739990234, 315.83038330078},
    [167] = {3822.7924804688, -767.53857421875, 314.17007446289},
    [168] = {3821.9479980469, -773.18072509766, 312.46734619141},
    [169] = {3821.2307128906, -779.00708007813, 310.58102416992},
    [170] = {3820.8190917969, -784.83349609375, 308.44354248047},
    [171] = {3821.3615722656, -790.23620605469, 306.08654785156},
    [172] = {3822.5405273438, -795.49566650391, 303.42004394531},
    [173] = {3823.7475585938, -800.83850097656, 300.43609619141},
    [174] = {3825.6831054688, -805.96466064453, 298.09259033203},
    [175] = {3828.5834960938, -810.55975341797, 296.1428527832},
    [176] = {3832.4360351563, -814.68377685547, 294.39910888672},
    [177] = {3836.4104003906, -818.52758789063, 292.89144897461},
    [178] = {3840.5922851563, -821.93811035156, 291.28115844727},
    [179] = {3845.0612792969, -825.25482177734, 289.70501708984},
    [180] = {3849.5185546875, -828.43829345703, 289.45346069336},
    [181] = {3854.1264648438, -831.72705078125, 288.99108886719},
    [182] = {3858.8200683594, -835.07678222656, 287.80236816406},
    [183] = {3863.2001953125, -838.20288085938, 287.63430786133},
    [184] = {3867.873046875, -840.81585693359, 287.21444702148},
    [185] = {3872.5087890625, -843.44696044922, 286.09289550781},
    [186] = {3876.5153808594, -847.10858154297, 284.60357666016},
    [187] = {3880.3500976563, -850.90875244141, 283.6457824707},
    [188] = {3884.3400878906, -854.86285400391, 282.68395996094},
    [189] = {3888.1687011719, -858.65686035156, 281.87548828125},
    [190] = {3891.9165039063, -862.37078857422, 281.24786376953},
    [191] = {3895.8256835938, -866.24481201172, 280.43893432617},
    [192] = {3899.6108398438, -869.99572753906, 279.47280883789},
    [193] = {3902.6186523438, -874.2392578125, 278.45492553711},
    [194] = {3902.6186523438, -874.2392578125, 278.45492553711}
}

--------------------VENDOR--------------------
VendorName = "Bale"
RepairVendor = "Altsoba Ragetotem"

VendorPoints = {
    [1] = {3902.3605957031, -873.16461181641, 278.65951538086},
    [2] = {3907.5671386719, -877.05712890625, 277.98184204102},
    [3] = {3913.1359863281, -880.20715332031, 277.36434936523},
    [4] = {3918.9716796875, -882.94622802734, 276.67016601563},
    [5] = {3925.3161621094, -883.67944335938, 275.57516479492},
    [6] = {3931.6923828125, -883.57403564453, 274.77365112305},
    [7] = {3938.4692382813, -884.3330078125, 273.94390869141},
    [8] = {3944.0029296875, -880.91125488281, 274.97607421875},
    [9] = {3950.0991210938, -877.26745605469, 275.86190795898},
    [10] = {3955.9797363281, -873.80377197266, 275.30282592773},
    [11] = {3961.2094726563, -873.46893310547, 274.41708374023},
    [12] = {3965.3791503906, -878.36761474609, 272.29501342773},
    [13] = {3968.30859375, -883.87084960938, 271.25534057617},
    [14] = {3971.6025390625, -887.74078369141, 270.76483154297},
    [15] = {3973.6433105469, -897.44696044922, 268.54998779297},
    [16] = {3976.7729492188, -902.24176025391, 266.75659179688},
    [17] = {3980.0354003906, -905.97418212891, 265.64263916016},
    [18] = {3984.2282714844, -910.60278320313, 264.42950439453},
    [19] = {3988.8220214844, -914.98510742188, 262.48583984375},
    [20] = {3994.3723144531, -915.61413574219, 259.68695068359},
    [21] = {4001.1320800781, -916.03997802734, 258.98883056641},
    [22] = {4006.3522949219, -916.16351318359, 258.83456420898},
    [23] = {4012.40234375, -915.2890625, 258.58947753906},
    [24] = {4018.9616699219, -914.99078369141, 258.27575683594},
    [25] = {4025.884765625, -914.68072509766, 258.05731201172},
    [26] = {4032.4416503906, -914.52606201172, 257.8603515625},
    [27] = {4038.5458984375, -913.29779052734, 257.8249206543},
    [28] = {4044.6596679688, -914.078125, 257.69097900391},
    [29] = {4050.9653320313, -913.34020996094, 257.56094360352},
    [30] = {4057.6457519531, -912.86322021484, 256.68267822266},
    [31] = {4062.9926757813, -908.34375, 256.54873657227},
    [32] = {4069.7280273438, -906.0146484375, 255.9271697998},
    [33] = {4076.0568847656, -903.26275634766, 255.64910888672},
    [34] = {4083.0053710938, -902.41851806641, 255.76536560059},
    [35] = {4089.8718261719, -901.89123535156, 255.74383544922},
    [36] = {4095.7006835938, -900.28948974609, 255.27696228027},
    [37] = {4101.9624023438, -900.48901367188, 254.88966369629},
    [38] = {4108.4877929688, -902.06225585938, 255.13320922852},
    [39] = {4115.3452148438, -903.49719238281, 255.62210083008},
    [40] = {4122.0244140625, -904.31225585938, 255.68295288086},
    [41] = {4129.146484375, -905.86566162109, 255.66645812988},
    [42] = {4134.7670898438, -907.68933105469, 256.79180908203},
    [43] = {4140.3813476563, -910.59283447266, 258.83786010742},
    [44] = {4144.9370117188, -914.15496826172, 261.03305053711},
    [45] = {4150.212890625, -917.48229980469, 263.23010253906},
    [46] = {4147.861328125, -922.98309326172, 265.13430786133},
    [47] = {4145.2919921875, -928.87664794922, 266.82247924805},
    [48] = {4143.67578125, -934.74078369141, 268.68591308594},
    [49] = {4142.064453125, -940.71539306641, 269.94708251953},
    [50] = {4141.1591796875, -946.87152099609, 272.15365600586},
    [51] = {4141.4853515625, -953.04919433594, 276.50796508789},
    [52] = {4142.6040039063, -958.75323486328, 279.1184387207},
    [53] = {4146.875, -962.67626953125, 279.68020629883},
    [54] = {4152.60546875, -961.10913085938, 280.31469726563},
    [55] = {4157.1909179688, -956.66613769531, 281.01608276367},
    [56] = {4161.7163085938, -953.04852294922, 281.61114501953},
    [57] = {4166.1665039063, -949.01312255859, 282.11148071289},
    [58] = {4170.6625976563, -944.74908447266, 282.39797973633},
    [59] = {4175.1025390625, -940.49401855469, 282.55743408203},
    [60] = {4179.3583984375, -936.57196044922, 282.69348144531},
    [61] = {4183.9814453125, -932.48767089844, 282.82440185547},
    [62] = {4188.7592773438, -928.31951904297, 282.96936035156},
    [63] = {4193.5595703125, -924.16375732422, 283.09527587891},
    [64] = {4197.8999023438, -920.31994628906, 283.25103759766},
    [65] = {4202.3969726563, -916.33734130859, 283.38433837891},
    [66] = {4207.478515625, -911.83709716797, 283.49377441406},
    [67] = {4211.8803710938, -907.20147705078, 283.56643676758},
    [68] = {4216.4702148438, -903.13677978516, 283.63952636719},
    [69] = {4220.8227539063, -899.09344482422, 283.69073486328},
    [70] = {4224.509765625, -894.46160888672, 283.83355712891},
    [71] = {4228.9497070313, -890.52947998047, 283.94177246094},
    [72] = {4233.3330078125, -886.64776611328, 284.04925537109},
    [73] = {4237.9584960938, -882.55151367188, 284.18719482422},
    [74] = {4242.4125976563, -878.60675048828, 284.15997314453},
    [75] = {4246.8168945313, -874.70611572266, 284.44259643555},
    [76] = {4251.4077148438, -870.81878662109, 285.87225341797},
    [77] = {4256.1977539063, -866.90124511719, 287.13027954102},
    [78] = {4260.974609375, -863.32965087891, 286.51733398438},
    [79] = {4266.0986328125, -859.86010742188, 284.70956420898},
    [80] = {4271.0126953125, -856.55706787109, 283.96951293945},
    [81] = {4276.1274414063, -853.31884765625, 284.47030639648},
    [82] = {4281.8920898438, -851.95697021484, 285.02871704102},
    [83] = {4288.0776367188, -852.07287597656, 285.43685913086},
    [84] = {4294.1484375, -851.89239501953, 285.75595092773},
    [85] = {4300.6572265625, -851.69885253906, 286.16458129883},
    [86] = {4306.880859375, -851.51379394531, 286.68661499023},
    [87] = {4313.0810546875, -851.45660400391, 287.29644775391},
    [88] = {4319.142578125, -851.5810546875, 287.76806640625},
    [89] = {4325.0737304688, -851.56781005859, 288.00952148438},
    [90] = {4330.9760742188, -851.55456542969, 288.29443359375},
    [91] = {4337.2114257813, -851.56744384766, 288.63143920898},
    [92] = {4343.1616210938, -851.60089111328, 289.0905456543},
    [93] = {4349.4345703125, -851.65106201172, 289.57553100586},
    [94] = {4355.5747070313, -851.70965576172, 290.0798034668},
    [95] = {4361.6674804688, -851.76782226563, 290.16958618164},
    [96] = {4368.1025390625, -851.82922363281, 290.39196777344},
    [97] = {4374.2333984375, -851.88775634766, 290.76058959961},
    [98] = {4380.4399414063, -851.94702148438, 291.11422729492},
    [99] = {4386.666015625, -852.00646972656, 291.46118164063},
    [100] = {4393.1391601563, -852.06823730469, 291.84661865234},
    [101] = {4399.650390625, -852.13037109375, 292.22863769531},
    [102] = {4405.923828125, -852.19024658203, 292.59564208984},
    [103] = {4412.2578125, -852.25073242188, 292.85061645508},
    [104] = {4418.4741210938, -852.31005859375, 292.92163085938},
    [105] = {4424.9091796875, -852.37152099609, 293.23937988281},
    [106] = {4430.7255859375, -852.42700195313, 293.58193969727},
    [107] = {4436.9038085938, -852.48602294922, 293.76000976563},
    [108] = {4443.2338867188, -852.54644775391, 293.89849853516},
    [109] = {4449.2216796875, -852.62713623047, 294.18450927734},
    [110] = {4455.294921875, -852.70892333984, 294.7526550293},
    [111] = {4461.3012695313, -852.82409667969, 295.39868164063},
    [112] = {4467.2954101563, -853.02258300781, 295.81518554688},
    [113] = {4473.2983398438, -853.16137695313, 296.22229003906},
    [114] = {4479.2827148438, -852.88055419922, 296.50524902344},
    [115] = {4485.298828125, -852.05230712891, 296.54553222656},
    [116] = {4491.57421875, -851.14489746094, 296.54553222656},
    [117] = {4498.2124023438, -850.18493652344, 296.54977416992},
    [118] = {4505.021484375, -850.08508300781, 296.55465698242},
    [119] = {4510.9858398438, -850.76403808594, 296.59008789063},
    [120] = {4517.6743164063, -851.19616699219, 296.56063842773},
    [121] = {4523.7827148438, -851.5908203125, 296.68905639648},
    [122] = {4529.5493164063, -851.96343994141, 297.25042724609},
    [123] = {4535.8857421875, -852.37274169922, 297.88247680664},
    [124] = {4541.9755859375, -852.26013183594, 298.57592773438},
    [125] = {4548.5405273438, -852.03912353516, 299.21853637695},
    [126] = {4555.0869140625, -851.81872558594, 299.77969360352},
    [127] = {4560.9658203125, -851.43585205078, 300.12237548828},
    [128] = {4566.8598632813, -850.04132080078, 300.23208618164},
    [129] = {4572.24609375, -847.30609130859, 300.19982910156},
    [130] = {4577.2924804688, -843.81262207031, 300.09332275391},
    [131] = {4582.3540039063, -839.90014648438, 299.99249267578},
    [132] = {4586.9565429688, -836.34283447266, 300.02676391602},
    [133] = {4591.7104492188, -832.75726318359, 300.09280395508},
    [134] = {4596.9526367188, -829.12414550781, 300.14031982422},
    [135] = {4601.8120117188, -825.94409179688, 300.18634033203},
    [136] = {4606.791015625, -822.70446777344, 300.03002929688},
    [137] = {4611.8852539063, -819.66870117188, 300.03518676758},
    [138] = {4617.0854492188, -816.73809814453, 299.94903564453},
    [139] = {4622.2290039063, -813.84252929688, 299.9362487793},
    [140] = {4627.8286132813, -810.69012451172, 299.94696044922},
    [141] = {4633.087890625, -807.72918701172, 299.93075561523},
    [142] = {4638.2895507813, -804.80096435547, 299.88723754883},
    [143] = {4643.6069335938, -801.80731201172, 300.04138183594},
    [144] = {4648.9248046875, -798.81372070313, 300.08721923828},
    [145] = {4654.1259765625, -795.88549804688, 299.97872924805},
    [146] = {4659.3525390625, -792.94323730469, 300.10568237305},
    [147] = {4664.5869140625, -789.99633789063, 299.96490478516},
    [148] = {4669.9794921875, -787.306640625, 299.90982055664},
    [149] = {4675.5864257813, -785.40447998047, 299.93740844727},
    [150] = {4681.5336914063, -783.73364257813, 299.95852661133},
    [151] = {4687.5400390625, -782.16717529297, 299.95700073242},
    [152] = {4693.5302734375, -780.61486816406, 299.95129394531},
    [153] = {4699.6953125, -779.01721191406, 299.95779418945},
    [154] = {4705.298828125, -777.56524658203, 299.95779418945},
    [155] = {4711.1782226563, -776.04156494141, 299.98690795898},
    [156] = {4717.0390625, -774.52270507813, 300.10888671875},
    [157] = {4723.01953125, -772.97064208984, 300.08798217773},
    [158] = {4728.6372070313, -770.42041015625, 299.96054077148},
    [159] = {4733.6577148438, -767.54089355469, 299.95837402344},
    [160] = {4738.7299804688, -764.57928466797, 299.95965576172},
    [161] = {4744.18359375, -761.47772216797, 299.96453857422},
    [162] = {4750.1137695313, -758.57073974609, 299.96063232422},
    [163] = {4756.359375, -755.98791503906, 299.95831298828},
    [164] = {4761.8334960938, -753.83135986328, 299.95831298828},
    [165] = {4767.3959960938, -751.63989257813, 299.95831298828},
    [166] = {4773.2983398438, -750.00146484375, 299.95831298828},
    [167] = {4779.5649414063, -748.45599365234, 299.95831298828},
    [168] = {4785.4467773438, -747.29626464844, 299.95541381836},
    [169] = {4791.5712890625, -746.28747558594, 299.95739746094},
    [170] = {4797.5361328125, -745.30499267578, 299.95846557617},
    [171] = {4803.69140625, -744.59399414063, 299.95590209961},
    [172] = {4809.6967773438, -743.98901367188, 299.98403930664},
    [173] = {4815.46484375, -743.40783691406, 300.10504150391},
    [174] = {4821.6879882813, -742.78082275391, 300.22323608398},
    [175] = {4827.5703125, -742.18823242188, 300.37200927734},
    [176] = {4833.4858398438, -741.59216308594, 300.70333862305},
    [177] = {4839.3681640625, -740.99957275391, 300.98748779297},
    [178] = {4845.8876953125, -740.52117919922, 301.38079833984},
    [179] = {4852.3706054688, -740.45574951172, 301.85064697266},
    [180] = {4858.9008789063, -740.39953613281, 302.27520751953},
    [181] = {4865.1362304688, -740.36108398438, 302.63897705078},
    [182] = {4871.0551757813, -740.32464599609, 302.97131347656},
    [183] = {4877.5859375, -740.28436279297, 303.25439453125},
    [184] = {4884.0498046875, -740.24456787109, 303.51907348633},
    [185] = {4890.3232421875, -740.20587158203, 303.5768737793},
    [186] = {4896.5673828125, -740.13824462891, 303.91665649414},
    [187] = {4902.8071289063, -739.88159179688, 304.52401733398},
    [188] = {4909.1665039063, -739.12487792969, 305.34020996094},
    [189] = {4915.37890625, -738.25140380859, 306.1692199707},
    [190] = {4921.7622070313, -737.50952148438, 306.70941162109},
    [191] = {4927.6708984375, -737.23529052734, 307.35018920898},
    [192] = {4934.3154296875, -737.46246337891, 307.96115112305},
    [193] = {4940.4174804688, -738.14654541016, 308.38284301758},
    [194] = {4946.2260742188, -738.79779052734, 308.75082397461},
    [195] = {4951.9877929688, -739.44372558594, 309.25735473633},
    [196] = {4958.8090820313, -740.20849609375, 309.6413269043},
    [197] = {4965.5263671875, -740.96154785156, 309.86447143555},
    [198] = {4972.158203125, -741.705078125, 310.68112182617},
    [199] = {4978.3740234375, -742.40191650391, 311.76092529297},
    [200] = {4984.150390625, -743.47027587891, 312.44262695313},
    [201] = {4990.0698242188, -744.86871337891, 312.94619750977},
    [202] = {4996.25, -746.28643798828, 313.43255615234},
    [203] = {5002.7436523438, -747.73229980469, 314.3938293457},
    [204] = {5008.6474609375, -748.9873046875, 315.45858764648},
    [205] = {5014.791015625, -750.21099853516, 316.60668945313},
    [206] = {5020.4702148438, -751.27850341797, 317.70852661133},
    [207] = {5026.8999023438, -752.03497314453, 318.98501586914},
    [208] = {5033.5541992188, -752.08813476563, 320.189453125},
    [209] = {5039.3994140625, -752.12097167969, 321.20602416992},
    [210] = {5046.5395507813, -752.16107177734, 322.38571166992},
    [211] = {5053.5649414063, -752.20056152344, 323.47268676758},
    [212] = {5060.6098632813, -752.24017333984, 324.42361450195},
    [213] = {5067.2641601563, -752.27752685547, 325.03076171875},
    [214] = {5073.7646484375, -752.189453125, 325.57568359375},
    [215] = {5080.0229492188, -751.75860595703, 326.26449584961},
    [216] = {5085.896484375, -750.57574462891, 327.06530761719},
    [217] = {5092.4326171875, -749.03002929688, 328.06488037109},
    [218] = {5098.4282226563, -747.74981689453, 328.92993164063},
    [219] = {5105.0986328125, -746.44024658203, 329.36892700195},
    [220] = {5111.3388671875, -745.63543701172, 329.38140869141},
    [221] = {5117.2612304688, -744.97204589844, 329.44180297852},
    [222] = {5123.5693359375, -744.85028076172, 329.64706420898},
    [223] = {5129.9555664063, -744.7607421875, 330.08602905273},
    [224] = {5136.1044921875, -744.67456054688, 330.82168579102},
    [225] = {5142.4731445313, -744.58526611328, 331.8821105957},
    [226] = {5148.5366210938, -744.50030517578, 333.16250610352},
    [227] = {5154.7524414063, -744.39709472656, 334.60601806641},
    [228] = {5160.5854492188, -743.46350097656, 336.05603027344},
    [229] = {5166.3793945313, -742.06719970703, 337.48138427734},
    [230] = {5171.6108398438, -739.58245849609, 338.72393798828},
    [231] = {5177.7690429688, -737.86077880859, 339.90975952148},
    [232] = {5182.3559570313, -734.14990234375, 340.78317260742},
    [233] = {5187.0883789063, -729.56243896484, 341.41632080078},
    [234] = {5191.974609375, -726.37493896484, 341.75134277344},
    [235] = {5197.6049804688, -722.7216796875, 342.18084716797},
    [236] = {5200.7470703125, -717.77447509766, 342.27508544922},
    [237] = {5204.0336914063, -713.41387939453, 342.5126953125},
    [238] = {5207.4047851563, -708.98498535156, 342.78176879883},
    [239] = {5205.37109375, -703.96447753906, 342.79501342773},
    [240] = {5198.0073242188, -703.60571289063, 342.97741699219},
    [241] = {5191.9165039063, -704.60980224609, 343.42391967773},
    [242] = {5185.5932617188, -704.1796875, 343.72235107422},
    [243] = {5179.5991210938, -701.65325927734, 341.58361816406},
    [244] = {5175.595703125, -697.10687255859, 338.89346313477},
    [245] = {5178.5751953125, -692.27551269531, 336.90805053711},
    [246] = {5182.1298828125, -687.58447265625, 334.74276733398},
    [247] = {5185.095703125, -682.2744140625, 331.72796630859},
    [248] = {5186.8569335938, -676.67614746094, 328.50427246094},
    [249] = {5187.7490234375, -670.91918945313, 325.56323242188},
    [250] = {5188.8178710938, -665.25109863281, 323.8596496582},
    [251] = {5190.5834960938, -658.50482177734, 323.20477294922},
    [252] = {5192.8754882813, -653.12530517578, 323.65417480469},
    [253] = {5195.9750976563, -647.99493408203, 323.95373535156},
    [254] = {5200.2358398438, -644.07928466797, 324.51007080078},
    [255] = {5205.5971679688, -641.2041015625, 325.7080078125},
    [256] = {5211.7890625, -638.47119140625, 327.01779174805},
    [257] = {5210.6206054688, -632.7548828125, 327.31985473633},
    [258] = {5211.642578125, -627.32427978516, 327.69860839844},
    [259] = {5213.5498046875, -621.90075683594, 327.98156738281},
    [260] = {5215.8813476563, -616.35461425781, 328.1208190918},
    [261] = {5216.3544921875, -610.97967529297, 328.17407226563},
    [262] = {5214.46875, -605.29620361328, 328.33221435547},
    [263] = {5213.8940429688, -599.59057617188, 328.78796386719},
    [264] = {5215.322265625, -593.27789306641, 328.94046020508},
    [265] = {5216.4536132813, -587.5791015625, 328.76968383789},
    [266] = {5216.0249023438, -581.52020263672, 328.65731811523},
    [267] = {5216.6713867188, -575.84381103516, 328.75430297852},
    [268] = {5219.7353515625, -570.35882568359, 328.9065246582},
    [269] = {5221.98046875, -565.2099609375, 329.06198120117},
    [270] = {5226.1840820313, -561.17810058594, 328.84432983398},
    [271] = {5230.6376953125, -556.9921875, 328.49984741211},
    [272] = {5235.3901367188, -552.93359375, 328.03411865234},
    [273] = {5240.3979492188, -548.96771240234, 327.35266113281},
    [274] = {5244.96484375, -545.01055908203, 326.3786315918},
    [275] = {5248.8115234375, -539.82104492188, 324.87835693359},
    [276] = {5252.490234375, -534.15057373047, 321.78881835938},
    [277] = {5255.7900390625, -529.01037597656, 318.05075073242},
    [278] = {5258.90234375, -523.54119873047, 317.38751220703},
    [279] = {5260.9887695313, -518.33734130859, 317.28012084961},
    [280] = {5262.798828125, -512.77227783203, 317.25701904297},
    [281] = {5262.826171875, -507.48303222656, 317.49685668945},
    [282] = {5262.81640625, -501.92730712891, 317.49682617188},
    [283] = {5262.806640625, -496.49029541016, 317.49682617188},
    [284] = {5262.7973632813, -491.23590087891, 317.4958190918},
    [285] = {5262.7861328125, -485.96871948242, 317.48977661133},
    [286] = {5260.6572265625, -480.12631225586, 317.78750610352},
    [287] = {5257.591796875, -474.7292175293, 318.87255859375},
    [288] = {5254.7827148438, -469.61196899414, 319.63409423828},
    [289] = {5251.8037109375, -463.66357421875, 320.67443847656},
    [290] = {5249.1420898438, -458.25, 321.31619262695},
    [291] = {5246.763671875, -452.70568847656, 322.00814819336},
    [292] = {5245.1635742188, -446.79724121094, 320.88259887695},
    [293] = {5243.5224609375, -440.66314697266, 320.78671264648},
    [294] = {5241.8959960938, -434.95104980469, 321.97705078125},
    [295] = {5238.8828125, -428.99792480469, 323.001953125},
    [296] = {5235.0698242188, -423.81875610352, 324.28652954102},
    [297] = {5231.1674804688, -419.4033203125, 327.19998168945},
    [298] = {5226.896484375, -414.55184936523, 329.51638793945},
    [299] = {5222.8896484375, -409.8151550293, 330.09332275391},
    [300] = {5219.0747070313, -405.05212402344, 329.95764160156},
    [301] = {5215.4536132813, -400.33599853516, 330.39767456055},
    [302] = {5212.0024414063, -395.48916625977, 330.36874389648},
    [303] = {5208.5278320313, -390.61215209961, 330.03485107422},
    [304] = {5204.943359375, -385.90963745117, 330.43103027344},
    [305] = {5201.0346679688, -381.23641967773, 330.79992675781},
    [306] = {5197.1342773438, -376.61764526367, 331.50698852539},
    [307] = {5193.0561523438, -371.78790283203, 332.5309753418},
    [308] = {5188.9716796875, -366.9508972168, 333.81201171875},
    [309] = {5184.9794921875, -362.22299194336, 335.24081420898},
    [310] = {5180.806640625, -357.60440063477, 336.98831176758},
    [311] = {5176.3989257813, -353.1630859375, 338.80773925781},
    [312] = {5171.9252929688, -349.42642211914, 340.60046386719},
    [313] = {5166.615234375, -346.58343505859, 342.62850952148},
    [314] = {5160.3779296875, -344.80895996094, 344.70538330078},
    [315] = {5153.984375, -344.26086425781, 347.1257019043},
    [316] = {5148.1372070313, -344.5234375, 349.09783935547},
    [317] = {5141.5390625, -345.4914855957, 351.44528198242},
    [318] = {5135.8505859375, -346.87307739258, 353.18090820313},
    [319] = {5130.099609375, -348.43591308594, 354.65515136719},
    [320] = {5123.68359375, -350.08908081055, 355.91976928711},
    [321] = {5117.7612304688, -351.56088256836, 356.76440429688},
    [322] = {5112.3310546875, -352.91946411133, 357.26913452148},
    [323] = {5105.1220703125, -354.65863037109, 357.15017700195},
    [324] = {5098.4067382813, -356.40417480469, 357.21908569336},
    [325] = {5094.9970703125, -357.65872192383, 357.26419067383, "Repair"}
}

DeleteItems = {[1] = {"OOX-09/HL Distress Beacon"}, [2] = {"Patch of Tainted Skin"}}

--------------------OPTIONS--------------------
PULSE_DELAY = 0.25
START_DELAY = 0.0

PROXIMAL_TOLERANCE = 4.4
ProximalTolerance = ProximalTolerance

IGNORE_LOS = true
STRICT_FOLLOW = true
SKIP_FAR_POINTS = false
RELOOP = true

--------------------IMPORTANT--------------------
MAX_LOOT_DIST = 30
LOOT_ON_VENDOR_PATH = true
SAFE_LOOTING = true -- Does not loot unit if it gets aggro

CLEAR_VENDOR_PATH = true -- Clears Vendor Path too (for safety), if has mount and set to FALSE will mount up (bit risky)
MOUNT_WHILE_GRINDING = true -- Mounts if targets are > mountCutOffDist dist from player or nil
MOUNT_CUT_OFF_DIST = 75

DC_ON_ITEM_BREAK = false -- If ANY inventory item breaks (Red) ==> DC [good for long afk sessions]
DC_HORDE_NEARBY = false

RANDOM_MAX = 100 -- Use values between 1 to 100 (100 varies pathing by 1 unit)

PULL_RANGE = 35 -- mage hunter
MELEE_RANGE = 10 -- hunter
LEVEL_MINUS = 6 -- don't attack targets below this lvl diff
LEVEL_PLUS = 4 -- don't attack targets above this lvl diff

POT_UP_HP = 25
POT_UP_MANA = 12

-- These are Auto Set
EatAtHP = 70
DrinkAtMana = 50
RECOVER_TILL_PERCENT = 88 -- once needs to drink/eat will do so till this HP

KITE = true -- Kite when possible

MIN_BAG_SLOTS = 1
DRAW_ENABLED = true
DRAW_WP_ENABLED = true
DRAW_TEXT_ENABLED = true

DRAW_ONLY = false -- to visualize path ONLY for configuring vendor paths

--------------------ALGORITHM--------------------

AtEnd = false -- do not touch

LastPulse = Wow.GetTime() + START_DELAY
CanPulseAt = LastPulse + PULSE_DELAY

LastDrawPulse = Wow.GetTime() + START_DELAY
CanDrawAt = LastPulse + 0.05

Frame = Wow.CreateFrame("Frame")
Frame.elapsed = 1

StuckTime = 0

-- Draw Shit
DestX = Waypoints[1][1]
DestY = Waypoints[1][2]
DestZ = Waypoints[1][3]

StatusStr = "WP"

function Exit(caller)
    Wow.DebugPrint('Exit called by: ' .. caller .. '()')
    Frame:SetScript("OnUpdate", nil)
end

function DismountCheck()
    if Wow.IsMounted() then
        Wow.Dismount()
    end
end

function GetLowestDurability()
    local lowest = 9999
    for i = 1, 22 do
        local current, maximum = Wow.GetInventoryItemDurability(i);
        if current ~= nil then
            if current < lowest then
                lowest = current
            end
        end
    end
    return lowest
end

function HasInInventory(item)
    for bag = 0, 4 do
        for slot = 0, Wow.GetContainerNumSlots(bag) do
            local link = Wow.GetContainerItemLink(bag, slot)
            if link then
                local sName, _, _, _, _, _, _, _ = Wow.GetItemInfo(link)
                if sName == item then
                    return true
                end
            end
        end
    end
    return false
end

function GetBandageName()
    for bag = 0, 4 do
        for slot = 0, Wow.GetContainerNumSlots(bag) do
            local link = Wow.GetContainerItemLink(bag, slot)
            if link then
                local sName, _, _, _, _, _, _, _ = Wow.GetItemInfo(link)
                if sName:find("Bandage") ~= nil then
                    return sName
                end
            end
        end
    end
    return ""
end

function CanDraw()
    local timeNow = Wow.GetTime()
    if timeNow >= CanDrawAt then
        LastDrawPulse = timeNow
        CanDrawAt = LastDrawPulse + 0.05
        return true
    end
    return false
end

function CanPulse()
    if DRAW_ONLY then
        return false
    end
    local timeNow = Wow.GetTime()
    if timeNow < CanPulseAt then
        return false
    end

    LastPulse = timeNow
    CanPulseAt = LastPulse + PULSE_DELAY
    return true
end

function ArrayContains(arr, search)
    for i = 1, #arr, 1 do
        if arr[i] == search then
            return true
        end
    end
    return false
end

function Sleep(secs)
    -- i forgot why this function is so scuffed but leave it as it is UNLESS you rewrite the whole codebase
    local timeNow = Wow.GetTime()
    if CanPulseAt > timeNow then -- since this func may be used several times in 1 cycle
        local overheadWait = CanPulseAt - timeNow;
        CanPulseAt = timeNow + overheadWait + secs
    else
        CanPulseAt = timeNow + secs
    end
end

function GetVendorSlot(itemName)
    for i = 1, 40 do
        local name, texture, price, quantity, numAvailable, isUsable, extendedCost = Wow.GetMerchantItemInfo(i);
        if name == nil then
            return -1
        elseif name == itemName then
            return i
        end
    end
end

PathIdx = 1
LOST_FLAGS = Wow.bit.bor(0x10, 0x100)

function CalculateDistance(x1, y1, z1, x2, y2, z2)
    return math.sqrt(((x1 - x2) ^ 2) + ((y1 - y2) ^ 2) + ((z1 - z2) ^ 2))
end

function IsInAggroRange(obj, tol)
    if tol == nil then
        tol = 5
    end

    local playerLevel = Wow.UnitLevel("player")
    if Wow.UnitIsEnemy("player", obj) and Wow.UnitIsDead(obj) == false then
        local unitLevel = Wow.UnitLevel(obj)
        local dist = Wow.GetDistanceBetweenObjects("player", obj)
        local aggroRad = (unitLevel - playerLevel) + 20 + tol -- suppost +20 imma to be safe +5
        return dist < aggroRad
    end
end

function PositionAggroCount()
    local count = 0
    for i = 1, Wow.GetObjectCount() do
        local obj = Wow.GetObjectWithIndex(i)
        if obj ~= nil then
            if Wow.UnitIsEnemy("player", obj) and Wow.UnitIsDead(obj) == false then
                local dist = Wow.GetDistanceBetweenObjects("player", obj)
                local aggroRad = Wow.UnitLevel(obj) - Wow.UnitLevel("player") + 20 + 3 -- suppost +20 imma to be safe +5
                if dist < aggroRad then
                    count = count + 1
                end
            end
        end
    end
    return count
end

-- Scan whole table and find closest point and always move to it (includes LOS checks)
-- Doesnt support jumping YET
function FindNextBestPoint()
    local px, py, pz = Wow.ObjectPosition("player")
    local moveToIdx = 1
    local moveToDist = 9999999
    local foundSomething = false

    for i = PathIdx, #Waypoints, 1 do
        local xyz = Waypoints[i]
        if xyz ~= nil then
            local dist = CalculateDistance(px, py, pz, xyz[1], xyz[2], xyz[3])

            if dist <= moveToDist then
                if dist > ProximalTolerance then
                    if i == #Waypoints then
                        AtEnd = true
                    end
                    -- local groundZ = GetGroundZ(xyz[1], xyz[2], losFlags)+2.5
                    if IGNORE_LOS == true or TraceLine(px, py, pz + 2.5, xyz[1], xyz[2], xyz[3] + 2.5, LOST_FLAGS) == nil then
                        foundSomething = true
                        moveToIdx = i
                        moveToDist = dist
                    end
                end
            end
        end
    end

    if foundSomething == true then
        PathIdx = moveToIdx
    else
        Wow.DebugPrint('Found No path in LOS!')
        PathIdx = 1;
        Wow.SendKey(' ')
    end

    local moveToXYZ = Waypoints[moveToIdx]
    Wow.MoveTo(moveToXYZ[1], moveToXYZ[2], moveToXYZ[3])
end

function IsMoving(Unit)
    if Unit == nil then
        return false
    end
    return Wow.GetUnitSpeed(Unit) > 0
end

AtVendor = false
AtStartAfterVendor = false
SellComplete = false
TalkedToVendor = false

VendorPathIdx = 1

FirstTick = true
function SetIDXToClosest(bWPOnly, limit)
    local px, py, pz = Wow.ObjectPosition("player")
    local moveToIdx = 1
    local moveToDist = 9999999
    local foundSomething = false

    local closestIsVendor = false
    local endWPCount = #Waypoints
    local start = 1
    if limit ~= nil then
        start = PathIdx - limit
        endWPCount = PathIdx + limit

        if start < 1 then
            start = 1
        end
        if endWPCount > #Waypoints then
            endWPCount = #Waypoints
        end
    end

    for i = start, endWPCount, 1 do
        local xyz = Waypoints[i]
        if xyz ~= nil then
            local dist = CalculateDistance(px, py, pz, xyz[1], xyz[2], xyz[3])

            if dist <= moveToDist then
                if IGNORE_LOS == true or TraceLine(px, py, pz + 2.5, xyz[1], xyz[2], xyz[3] + 2.5, LOST_FLAGS) == nil then
                    foundSomething = true
                    moveToIdx = i
                    moveToDist = dist
                    closestIsVendor = false
                end
            end
        end
    end

    if bWPOnly ~= nil and bWPOnly then
        if foundSomething then
            PathIdx = moveToIdx
            Wow.DebugPrint("Starting at grind path at idx " .. PathIdx)
        end
        return
    end

    for i = 1, #VendorPoints, 1 do
        local xyz = VendorPoints[i]
        if xyz ~= nil then
            local dist = CalculateDistance(px, py, pz, xyz[1], xyz[2], xyz[3])

            if dist <= moveToDist then
                if IGNORE_LOS == true or TraceLine(px, py, pz + 2.5, xyz[1], xyz[2], xyz[3] + 2.5, LOST_FLAGS) == nil then
                    foundSomething = true
                    moveToIdx = i
                    moveToDist = dist
                    closestIsVendor = true
                end
            end
        end
    end

    if foundSomething == true then
        if closestIsVendor then
            VendorPathIdx = moveToIdx
            Wow.DebugPrint("Walking back to leveling path from vendor from idx " .. VendorPathIdx)
            SellComplete = true
            AtStartAfterVendor = false
        else
            PathIdx = moveToIdx
            Wow.DebugPrint("Starting at grind path at idx " .. PathIdx)
        end
    else
        Wow.DebugPrint('WARNING: Could not find a close point in SetIDXToClosest()')
    end

end

LastIdx = nil
LastIdxCount = 0

function FirstTickApply()
    if Wow.IsHunter() then
        EatAtHP = 69
        DrinkAtMana = 33
    elseif Wow.IsMage() then
        Wow.DebugPrint("Applying Mage Mana/HP Preset!")
        EatAtHP = 75
        DrinkAtMana = 75
    end
end

FirstTickApply()
-- Follow path from index 1 to end
-- !THIS FUNCTION IS A MESS! RE-WRITE
function StrictPathFollow()
    if FirstTick == true then
        FirstTick = false
        SetIDXToClosest()
    end

    local px, py, pz = Wow.ObjectPosition("player")
    local xyz = Waypoints[PathIdx] -- return is imp to always assign next xyz correctly

    if Wow.UnitIsDeadOrGhost("player") then
        -- Get Distance from Corpse
        -- /script AcceptResurrect()
    end

    if xyz ~= nil then
        -- Add Class Specific
        -- !Move this to last (after movement!!!)
        if xyz[4] ~= nil then
            -- Define 4th Param Stuff
        end

        local dist = CalculateDistance(px, py, pz, xyz[1], xyz[2], xyz[3])
        -- print(' = DIST: '..dist)
        if dist <= ProximalTolerance then
            if PathIdx < #Waypoints then
                PathIdx = PathIdx + 1
                -- print('Moving to idx {'..pathIdx..'/'..#Waypoints..'}')
                Wow.DebugPrint('Moving to idx {' .. PathIdx .. '/' .. #Waypoints .. '}')
                return
            else
                AtEnd = true
            end
        end
    end

    -- Check if Stuck
    if PathIdx == LastIdx then
        LastIdxCount = LastIdxCount + 1
        StuckTime = StuckTime + PULSE_DELAY
    else
        StuckTime = 0
        LastIdxCount = 0
    end

    -- Skip if stuck (forced) but never skip last post so as to trigger the appropriate fail safes
    -- using counter in the form of lastIdxCount is mehhh coz doesnt give indication of time stuck (we vary pulseDelay all the time)
    if LastIdxCount > 20 and (PathIdx < #Waypoints - 2) then
        local stuckStr = 'Appears to be STUCK: at idx=' .. PathIdx
        print(stuckStr)
        Wow.WriteFile('/Log/Stuck.txt', stuckStr .. '\n', true)
        -- local prevIdx = pathIdx
        -- pathIdx = 1
        -- FindNextBestPoint()
        Wow.SendKey(' ')
        PathIdx = PathIdx + 1
        AtEnd = PathIdx > #Waypoints
        return
    end

    if PathIdx < 1 then
        PathIdx = 1
    elseif PathIdx > #Waypoints then
        PathIdx = #Waypoints
        AtEnd = true
    end

    -- Move
    local rnd = (math.random(-RANDOM_MAX, RANDOM_MAX) / 100)
    local moveToXYZ = Waypoints[PathIdx]
    if moveToXYZ ~= nil then
        DestX = moveToXYZ[1] + rnd
        DestY = moveToXYZ[2] + rnd
        DestZ = moveToXYZ[3] + rnd
    end

    StatusStr = "WP"
    local distToNext = CalculateDistance(px, py, pz, moveToXYZ[1], moveToXYZ[2], moveToXYZ[3])
    if SKIP_FAR_POINTS == false or (SKIP_FAR_POINTS and distToNext < 50) then
        if IGNORE_LOS == true or TraceLine(px, py, pz + 2.5, moveToXYZ[1], moveToXYZ[2], moveToXYZ[3] + 2.5, LOST_FLAGS) == nil then
            Wow.MoveTo(moveToXYZ[1] + rnd, moveToXYZ[2] + rnd, moveToXYZ[3] + rnd)
        end
    else
        if SKIP_FAR_POINTS then
            Wow.DebugPrint('*Skipping* to idx {' .. PathIdx .. '/' .. #Waypoints .. '}')
            PathIdx = PathIdx + 1
            AtEnd = PathIdx > #Waypoints
            return
        else
            Wow.DebugPrint('*Waiting* for player to be close to path...')
        end
    end

    LastIdx = PathIdx
end

-- Processes path relooping and Exit()
function PathEndCheck()
    if AtEnd then
        if RELOOP then
            local startXYZ = Waypoints[1]
            if IGNORE_LOS or TraceLine(px, py, pz + 2.5, startXYZ[1], startXYZ[2], startXYZ[3] + 2.5) == nil then
                -- is start is in not in LOS
                AtEnd = false

                local p1 = Waypoints[1]
                local p2 = Waypoints[#Waypoints]
                local distBetween = CalculateDistance(p1[1], p1[2], p1[3], p2[1], p2[2], p2[3])

                if distBetween > 50 then
                    Wow.DebugPrint('Reversing Path!!!')
                    local i, j = 1, #Waypoints
                    while i < j do
                        Waypoints[i], Waypoints[j] = Waypoints[j], Waypoints[i]
                        i = i + 1
                        j = j - 1
                    end
                else
                    Wow.DebugPrint('ReLooping Path!!!')
                end

                PathIdx = 1
            else
                Wow.DebugPrint('Cannot ReLoop as Start is not in LOS!')
                PathIdx = 1
            end
        else
            Wow.DebugPrint('Finished Pathing!!!')
            Exit('PathEndCheck')
        end
    end
end

function GetFreeSlots()
    local freeSlots = 0
    for i = 1, 5 do
        local numberOfFreeSlots, BagType = Wow.GetContainerNumFreeSlots(i - 1);
        if BagType == 0 then -- https://wowwiki.fandom.com/wiki/ItemFamily
            freeSlots = freeSlots + Wow.GetContainerNumFreeSlots(i - 1)
        end
    end
    return freeSlots
end

function HasMount()
    if MOUNT_NAME == "" or MOUNT_NAME == nil then
        return false
    end
    for bag = 0, 4 do
        for slot = 0, Wow.GetContainerNumSlots(bag) do
            local link = Wow.GetContainerItemLink(bag, slot)
            if link then
                local sName, _, _, _, _, _, _, _ = Wow.GetItemInfo(link)
                if sName == MOUNT_NAME then
                    return true
                end
            end
        end
    end

    return false
end

function HasManaGem()
    if Wow.IsMage() == false then
        return false
    end
    for bag = 0, 4 do
        for slot = 0, Wow.GetContainerNumSlots(bag) do
            local link = Wow.GetContainerItemLink(bag, slot)
            if link then
                local sName, _, _, _, _, _, _, _ = Wow.GetItemInfo(link)
                if sName == "Mana Agate" or sName == "Mana Jade" or sName == "Mana Citrine" then
                    return true
                end
            end
        end
    end

    return false
end

function VendorPath(bToVendor)
    local px, py, pz = Wow.ObjectPosition("player")
    local xyz = VendorPoints[VendorPathIdx] -- return is imp to always assign next xyz correctly

    if Wow.IsHunter() and HunterBuff ~= "Aspect of the Cheetah" and HasMount() == false then
        HunterBuff = "Aspect of the Cheetah"
    end

    if xyz ~= nil then
        local dist = math.abs(CalculateDistance(px, py, pz, xyz[1], xyz[2], xyz[3]))
        if dist <= ProximalTolerance then
            if bToVendor and VendorPathIdx <= #VendorPoints then
                VendorPathIdx = VendorPathIdx + 1
            elseif VendorPathIdx > 1 then
                VendorPathIdx = VendorPathIdx - 1
            end
            Wow.DebugPrint('Moving to vendor idx {' .. VendorPathIdx .. '/' .. #VendorPoints .. '}')
        end

        local action = xyz[4]
        if action ~= nil then
            if bToVendor == false then
                if action == "Repair" then
                    Wow.DebugPrint("Going to Repair Vendor...")
                    Wow.InteractUnit(RepairVendor)
                    Sleep(10)

                    if bToVendor and VendorPathIdx <= #VendorPoints then
                        VendorPathIdx = VendorPathIdx + 1
                    elseif VendorPathIdx > 1 then
                        VendorPathIdx = VendorPathIdx - 1
                    end
                    return
                elseif action == "Stop" then
                    Wow.DebugPrint("Stopping!")
                    Wow.SendKey(83, 123)
                    Sleep(3)

                    if bToVendor and VendorPathIdx <= #VendorPoints then
                        VendorPathIdx = VendorPathIdx + 1
                    elseif VendorPathIdx > 1 then
                        VendorPathIdx = VendorPathIdx - 1
                    end
                    return
                end
            end
        end
    end

    local rnd = math.random(-RANDOM_MAX, RANDOM_MAX) / 100
    local moveToXYZ = VendorPoints[VendorPathIdx]
    if moveToXYZ ~= nil then
        DestX = moveToXYZ[1] + rnd
        DestY = moveToXYZ[2] + rnd
        DestZ = moveToXYZ[3] + rnd
        StatusStr = "VENDOR"

        if VendorPathIdx == #VendorPoints then
            Wow.MoveTo(moveToXYZ[1], moveToXYZ[2], moveToXYZ[3]) -- don't want random fuck ups
        else
            Wow.MoveTo(moveToXYZ[1] + rnd, moveToXYZ[2] + rnd, moveToXYZ[3] + rnd)
        end
    end

    if bToVendor and VendorPathIdx >= #VendorPoints then
        AtVendor = true
    elseif bToVendor == false and VendorPathIdx <= 1 then
        AtStartAfterVendor = true
        SetIDXToClosest(true)
    end
end

GoingToVendor = false

function EmptyBagsSetup()
    -- Check Drinks + Food
    -- Check Arrows +/ if equipped too
    if #VendorPoints <= 1 then -- no vendor path
        return false
    end

    local criticalAmmoCount = (#VendorPoints + (#Waypoints - PathIdx)) * 1.5
    local freeSlots = GetFreeSlots()
    if freeSlots <= MIN_BAG_SLOTS or (Wow.IsHunter() and Wow.GetItemCount(Hunter:GetAmmoName()) <= criticalAmmoCount) then
        local px, py, pz = Wow.ObjectPosition("player")
        local closestDist = 99999
        for i = 1, #VendorPoints do
            local xyz = VendorPoints[i]
            if xyz ~= nil then
                local dist = CalculateDistance(px, py, pz, xyz[1], xyz[2], xyz[3])
                if dist < closestDist then
                    closestDist = dist
                    VendorPathIdx = i
                end
            end
        end

        if closestDist < 30 then
            Wow.DebugPrint('Vendoring!!!!!!')
            GoingToVendor = true
            return true
        end

        Wow.DebugPrint('Bags full but not close enough to Vendor path [75y]. Closest = ' .. closestDist)
    end

    return false
end

Spell = ""
PauseWPMovTil = 0

function PulseMovement()
    if Wow.GetTime() < PauseWPMovTil then
        Spell = "Waiting NPC to Pass"
        Wow.DebugPrint("WP Movement is Paused")
        Sleep(1)
        return
    end
    if STRICT_FOLLOW == true then
        StrictPathFollow()
    else
        FindNextBestPoint()
    end
end

function IsInCombat(Unit)
    return Wow.UnitAffectingCombat(Unit)
end

AttackObj = nil

function IsTargeting(obj, tar)
    if obj == nil or tar == nil then
        return false
    end
    local unitTarget = Wow.UnitTarget(obj)
    if unitTarget == nil then
        return false
    end

    return Wow.UnitGUID(unitTarget) == Wow.UnitGUID(tar)
end

function GetUnitHP(unit)
    return 100 * Wow.UnitHealth(unit) / Wow.UnitHealthMax(unit)
end

function GetUnitMana(unit)
    return 100 * Wow.UnitPower(unit) / Wow.UnitPowerMax(unit)
end

EnemyNPCs = {}
EnemyPlayers = {}

function ClearTargetDrawTables()
    for k in pairs(EnemyPlayers) do
        EnemyPlayers[k] = nil
    end
    for k in pairs(EnemyNPCs) do
        EnemyNPCs[k] = nil
    end
end

function RecoverMana()
    if IsMoving("player") then
        Wow.SendKey(83, 123)
    end

    if IsMoving("player") then
        return false
    end

    for bag = 0, 4 do
        for slot = 0, Wow.GetContainerNumSlots(bag) do
            local link = Wow.GetContainerItemLink(bag, slot)
            if link then
                local name, _, _, _, _, _, _, _ = Wow.GetItemInfo(link)
                for i = 1, #Drinks, 1 do
                    if name == Drinks[i] then
                        Wow.DebugPrint("Recovering Mana...")
                        DismountCheck()
                        Wow.UseContainerItem(bag, slot)
                        StatusStr = "RECOVERING"
                        ClearTargetDrawTables()
                        Sleep(2.1)
                        return true
                    end
                end
            end
        end
    end

    Wow.DebugPrint("Unable to find a Drink to restore Mana...")
    return false
end

function RecoverHP()
    if IsMoving("player") then
        local xx, yy, zz = Wow.ObjectPosition("player")
        Wow.MoveTo(xx, yy, zz)
    end

    if IsMoving("player") then
        return false
    end

    for bag = 0, 4 do
        for slot = 0, Wow.GetContainerNumSlots(bag) do
            local link = Wow.GetContainerItemLink(bag, slot)
            if link then
                local name, _, _, _, _, _, _, _ = Wow.GetItemInfo(link)
                for i = 1, #Foods, 1 do
                    if name == Foods[i] then
                        Wow.DebugPrint("Recovering Health...")
                        DismountCheck()
                        Wow.UseContainerItem(bag, slot)
                        StatusStr = "RECOVERING"
                        ClearTargetDrawTables()
                        Sleep(2.1)
                        return true
                    end
                end
            end
        end
    end

    Wow.DebugPrint("Unable to find Food to restore HP...")
    return false
end

function MendingPet()
    local isEating = Wow.HasAura("player", "Food")
    local isDrinking = Wow.HasAura("player", "Drink")
    if isEating or isDrinking then
        Sleep(1.1)
        return false
    end

    local petHP = GetUnitHP("pet")
    if Wow.UnitExists("pet") and petHP > 0 and petHP < PetMendHP then
        local distToPet = Wow.GetDistanceBetweenObjects("player", "pet")
        if distToPet < 20 and Wow.IsCastable("Mend Pet") then
            local _, castChannelID, _, _ = Wow.UnitCastID("player") -- ??might be first var but idk
            if castChannelID == 136 then -- If already casting mend
                Wow.DebugPrint('Pet is being Healed!')
                Sleep(1)
            else -- If not casting mend
                Wow.DebugPrint('Healing Pet!!!')
                if IsTargeting("target", "pet") then
                    PetMendHP = 75
                else
                    PetMendHP = 95
                end
                Wow.CastSpellByName("Mend Pet", false)
                Sleep(5.1)
            end
            return true
        end
    else
        PetMendHP = PET_MEND_HP
    end

    return false
end

RevivePetStuck = 0
LastFedTime = 0
CallingPet = false

function ManagePet() -- True = Continue, False = Retick
    if Wow.IsHunter() == false or Wow.HasAura("player", "Feign Death") then
        return true
    end

    if IsInCombat("player") then -- Res Combat
        if Wow.UnitExists("pet") == false and RevivePetStuck < 1 then
            RevivePetStuck = RevivePetStuck + 1
            Wow.RunMacroText("/cast Call Pet")
        end
        return true
    end

    -- 复活或者召出宝宝
    if (Wow.UnitExists("pet") == false or Wow.UnitIsDead("pet") or Wow.UnitHealth("pet") <= 0) and Wow.UnitCastID("player") == 0 and RevivePetStuck < 5 then
        if CallingPet == false then
            CallingPet = true
            Wow.RunMacroText("/cast Call Pet")
            Sleep(1.5)
            RevivePetStuck = RevivePetStuck + 1
        else
            CallingPet = false
            Wow.RunMacroText("/cast Revive Pet")
            Sleep(8)
            RevivePetStuck = RevivePetStuck + 1
        end
        return false
    else
        RevivePetStuck = 0
    end
    if Wow.UnitExists("pet") == false then
        return false
    end

    -- 太远了, 就改成跟随
    local distFromPet = Wow.GetDistanceBetweenObjects("player", "pet")
    if distFromPet > PULL_RANGE + 1 then
        for i = 1, 10, 1 do
            local name, _, _, _, _, _, _ = Wow.GetPetActionInfo(i);
            if (name == "PET_ACTION_FOLLOW") then
                Wow.CastPetAction(i);
            end
        end
    end

    if IsInCombat("player") then
        return true -- Actions below should be OUT OF COMBAT
    end

    -- 喂食
    local happiness, damagePercentage, loyaltyRate = Wow.GetPetHappiness()
    local happy = true
    if happiness ~= nil then
        happy = happiness > 2
    end
    if Wow.HasAura("pet", "Feed Pet Effect") and happy == false then
        Sleep(2)
        Spell = "Pet Feed - WAIT"
        Wow.DebugPrint("Waiting for Pet Feeding Effect")
        return false
    end
    if happy == false and distFromPet < 10 then
        local elapsedSinceLastFed = Wow.GetTime() - LastFedTime
        if elapsedSinceLastFed > 10 then -- I have an overfeeding 'bug' - probably timer ticking before feed aura is up
            for i = 1, #PetFoods, 1 do
                if HasInInventory(PetFoods[i]) then
                    Wow.DebugPrint("Feeding Unhappy Pet [" .. PetFoods[i] .. "]")
                    Wow.RunMacroText("/use Feed Pet")
                    Wow.RunMacroText("/use " .. PetFoods[i])
                    LastFedTime = Wow.GetTime()
                    Sleep(5)
                    return false
                end
            end

            Wow.DebugPrint("No Pet Food!")
        end
    end

    -- 加血
    if MendingPet() then
        return false
    end
end

function IsItemUsable(itemName)
    local usable, nomana = Wow.IsUsableItem(itemName)
    if usable == false or nomana then
        return false
    end
    for bag = 0, 4 do
        for slot = 0, Wow.GetContainerNumSlots(bag) do
            local link = Wow.GetContainerItemLink(bag, slot)
            if link then
                local sName, _, _, _, _, _, _, _ = Wow.GetItemInfo(link)
                if sName == itemName then
                    local startTime, duration, isEnabled = Wow.GetContainerItemCooldown(bag, slot)
                    return startTime == 0
                end
            end
        end
    end

    return false
end

PvpTargeted = false

function Potion()
    if IsInCombat("player") == false or PvpTargeted then
        return false
    end

    local needHP = GetUnitHP("player") <= POT_UP_HP
    local needMana = GetUnitMana("player") <= POT_UP_MANA
    if needHP == false and needMana == false then
        return false
    end

    local hasMageManaGem = false
    if Wow.IsMage() then
        hasMageManaGem = HasManaGem()
    end

    local bag, slot
    local total = 0
    for bag = 0, 4 do
        for slot = 0, Wow.GetContainerNumSlots(bag) do
            local link = Wow.GetContainerItemLink(bag, slot)
            if link then
                local sName, _, _, _, _, _, _, _ = Wow.GetItemInfo(link)

                if needHP and sName:find("Healing Potion") and IsItemUsable(sName) then
                    Wow.DebugPrint('Drinking [' .. sName .. '] for HEALTH!')
                    Wow.SpellStopCasting()
                    Wow.RunMacroText('/use ' .. sName)
                    -- Wow.UseContainerItem(bag, slot, 1)
                    return true
                end

                if needMana and (hasMageManaGem and sName == "Mana Jade" or sName == "Mana Agate" or sName == "Mana Citrine") or (sName:find("Mana Potion") and hasMageManaGem == false) then
                    if hasMageManaGem and Wow.IsCastable("Evocation") then
                        -- we can evocate
                    else
                        if IsItemUsable(sName) then
                            Wow.DebugPrint('Drinking [' .. sName .. '] for MANA!')
                            Wow.SpellStopCasting()
                            Wow.RunMacroText('/use ' .. sName)
                            -- Wow.UseContainerItem(bag, slot, 1)
                            return true
                        end
                    end
                end
            end
        end
    end

    return false
end

ConjureCount = 0

function Conjure()
    if Wow.IsMage() == false or Wow.IsMounted() or GetFreeSlots() <= 1 then
        return false
    end

    if ConjureCount > 7 then -- Sit stuck
        Wow.SendKey(87, 223)
        ConjureCount = 0
    end

    -- 制作水喝食物
    if Wow.GetItemCount(Drinks[1]) < 12 then
        Wow.DebugPrint("Conjuring Water!")
        ConjureCount = ConjureCount + 1
        DismountCheck()
        Wow.CastSpellByName("Conjure Water")
        Sleep(1)
        return true
    end
    if Wow.GetItemCount(Foods[1]) < 12 then
        Wow.DebugPrint("Conjuring Food!")
        ConjureCount = ConjureCount + 1
        DismountCheck()
        Wow.CastSpellByName("Conjure Food")
        Sleep(1)
        return true
    end

    -- 制作法力宝石
    local jadeCount = Wow.GetItemCount("Mana Citrine")
    if Wow.IsCastable("Conjure Mana Citrine") and jadeCount == 0 then
        Wow.DebugPrint("Conjuring Mana Citrine!")
        ConjureCount = ConjureCount + 1
        DismountCheck()
        Wow.CastSpellByName("Conjure Mana Citrine")
        Sleep(1)
        return true
    elseif Wow.IsCastable("Conjure Mana Jade") and jadeCount == 0 then
        Wow.DebugPrint("Conjuring Mana Jade!")
        ConjureCount = ConjureCount + 1
        DismountCheck()
        Wow.CastSpellByName("Conjure Mana Jade")
        Sleep(1)
        return true
    elseif jadeCount == 0 and Wow.IsCastable("Conjure Mana Agate") and Wow.GetItemCount("Mana Agate") == 0 then
        Wow.DebugPrint("Conjuring Mana Agate!")
        ConjureCount = ConjureCount + 1
        DismountCheck()
        Wow.CastSpellByName("Conjure Mana Agate")
        Sleep(1)
        return true
    end
    ConjureCount = 0
end

StallBuffUp = 0

function ApplyBuff(buff)
    if Wow.IsCastable(buff) == false or Wow.IsMounted() == true and Wow.UnitCastID("player") ~= 0 and Wow.GetTime() < StallBuffUp then
        return
    end
    Wow.ApplyBuff(buff)
    Sleep(0.5)
end

function ApplyBuffs()
    if Wow.IsMage() then
        ApplyBuff("Arcane Intellect")
        if PREFER_MAGE_ARMOR then
            ApplyBuff("Mage Armor")
        else
            ApplyBuff("Ice Armor")
        end
        ApplyBuff("Ice Barrier")
    elseif Wow.IsHunter() then
        ApplyBuff(HunterBuff)
    end
end

function CheckVitals()
    if Wow.UnitIsDeadOrGhost("player") then
        StatusStr = "DEAD"
        return false
    end

    if Wow.IsSwimming() or Wow.IsMounted() then
        return true
    end

    local playerHp = GetUnitHP("player")
    local playerMana = GetUnitMana("player")
    local isEating = Wow.HasAura("player", "Food")
    local isDrinking = Wow.HasAura("player", "Drink")
    if isEating and playerHp < RECOVER_TILL_PERCENT then
        return false
    end
    if isDrinking and playerMana < RECOVER_TILL_PERCENT then
        return false
    end

    -- 管理猎人宝宝
    if ManagePet() == false then
        if playerMana < DrinkAtMana then
            RecoverMana()
            return false
        end
        return false
    end

    -- 战斗中直接退出, 以下动作无法执行
    if IsInCombat("player") then
        return true
    end

    -- 加buff
    ApplyBuffs()

    -- 吃喝
    if playerHp < EatAtHP then
        RecoverHP()
        if playerMana < DrinkAtMana then
            RecoverMana()
        end
        return false
    end
    if playerMana < DrinkAtMana then
        RecoverMana()
        return false
    end
    if isEating or isDrinking then -- 吃喝结束
        Wow.SendKey(' ') -- no longer sit
    end

    -- 法师制作水, 食物, 宝石
    if Wow.IsMage() and Conjure() then
        return false
    end

    return true
end

function EnemyNearby(obj)
    if DC_HORDE_NEARBY and IsInCombat("player") == false then
        local dist = Wow.GetDistanceBetweenObjects(obj, "player")
        if dist > 100 then
            return
        end

        if Wow.UnitLevel("player") - Wow.UnitLevel(obj) > 10 then -- Harmless Enemy
            return
        end

        Wow.WriteFile("/Log/ReLog.txt", '600', false)
        Wow.RunMacroText(".dc")
    end
end

function AggrodToAnotherPlayer(obj)
    local hp = GetUnitHP(obj)
    if hp == 0 or Wow.UnitTarget(obj) == nil then
        return false
    end

    if Wow.IsMage() == false then
        if Wow.HasDebuff("Frost Nova", obj) then
            return true
        end
    end

    local targetMe = IsTargeting(obj, "player")
    if Wow.IsHunter() == false then
        return (not targetMe)
    elseif Wow.IsHunter() then
        return targetMe == false and IsTargeting(obj, "pet") == false
    end

    return false
end

function MoveFacingObject(obj, div, into)
    local px, py, pz = Wow.ObjectPosition("player")
    local ox, oy, oz = Wow.ObjectPosition(obj)
    local dx = (px - ox) / div
    local dy = (py - oy) / div
    local dz = (pz - oz) / div
    local mx, my, mz

    if into then
        if dx < 0 then
            mx = px + math.abs(dx)
        else
            mx = px - math.abs(dx)
        end
        if dy < 0 then
            my = py + math.abs(dy)
        else
            my = py - math.abs(dy)
        end
        if dz < 0 then
            mz = pz + math.abs(dz)
        else
            mz = pz - math.abs(dz)
        end
    else
        if dx < 0 then
            mx = px - math.abs(dx)
        else
            mx = px + math.abs(dx)
        end
        if dy < 0 then
            my = py - math.abs(dy)
        else
            my = py + math.abs(dy)
        end
        if dz < 0 then
            mz = pz - math.abs(dz)
        else
            mz = pz + math.abs(dz)
        end
    end

    Wow.MoveTo(mx, my, mz)
end

CombatTime = 0
TargetIsFar = false
AggroTable = {}

-- Holy shit this function is a mess
function FindAttackableUnit()
    local keepAttObj = false
    -- This part is to make sure that we don't tag two different targets because incombat would be false and this function returns two diff targets 
    if AttackObj ~= nil then
        if Wow.UnitExists(AttackObj) and Wow.UnitIsDead(AttackObj) == false or Wow.UnitCastID("player") ~= 0 and GetUnitHP(AttackObj) > 0 then -- Keep Target --? but what if not aggrod
            if CombatTime < 3 and Wow.GetDistanceBetweenObjects("player", AttackObj) < PULL_RANGE + 3 then
                -- print('Keeping Target '..Wow.ObjectName(attackObj)..' at '..GetUnitHP(attackObj))
                keepAttObj = true
            end
        end
    end
    local px, py, pz = Wow.ObjectPosition("player")

    local playerLvl = Wow.UnitLevel("player")
    local minAttLvl = playerLvl - LEVEL_MINUS
    local maxAttLvl = playerLvl + LEVEL_PLUS

    -- CLEAR Tables to choose from
    local targetTable = {}
    for k in pairs(AggroTable) do
        AggroTable[k] = nil
    end

    -- Clear out liest each scan otherwise clutter 101
    ClearTargetDrawTables()
    TargetIsFar = false
    PvpTargeted = false

    -- Fill target tables
    for i = 1, Wow.GetObjectCount() do
        local obj = Wow.GetObjectWithIndex(i)
        local name = Wow.ObjectName(obj)

        -- Enemy Player/NPC Check for Drawing
        if Wow.UnitIsEnemy("player", obj) and Wow.UnitIsDead(obj) == false then
            local ex, ey, ez = Wow.ObjectPosition(obj)
            local arr = {ex, ey, ez, Wow.UnitLevel(obj), Wow.ObjectName(obj)}
            if Wow.UnitIsPlayer(obj) then
                EnemyNearby(obj)
                table.insert(EnemyPlayers, arr)
            else
                table.insert(EnemyNPCs, arr)
            end
        end

        if string.find(name, "Totem") == nil and Wow.UnitCanAttack("player", obj) then
            local unitLvl = Wow.UnitLevel(obj)
            local unitHp = GetUnitHP(obj)
            local targettingMe = IsTargeting(obj, "player")
            if Wow.HasDebuff("Frost Nova", obj) then
                targettingMe = true
            end
            if Wow.IsHunter() and IsTargeting(obj, "pet") then
                targettingMe = true
            end

            if targettingMe or (unitLvl >= minAttLvl and unitLvl <= maxAttLvl) and unitHp > 0 and Wow.UnitIsDead(obj) == false then
                local ox, oy, oz = Wow.ObjectPosition(obj)
                -- Stop Pet Auto-Aggro Player
                if Wow.IsHunter() and Wow.UnitIsPlayer(obj) then
                    if IsTargeting("pet", obj) then
                        for i = 1, 10, 1 do
                            local name, _, _, _, _, _, _ = Wow.GetPetActionInfo(i);
                            if (name == "PET_ACTION_FOLLOW") then
                                Wow.CastPetAction(i);
                            end
                        end
                    end
                end

                local isPlayer = Wow.UnitIsPlayer(obj)
                if isPlayer == false and TraceLine(px, py, pz + 2.5, ox, oy, oz + 2.5, LOST_FLAGS) == nil and AggrodToAnotherPlayer(obj) == false then
                    if IsInCombat(obj) and targettingMe then -- Targetting me so auto fook him up
                        table.insert(AggroTable, obj)
                    elseif ArrayContains(AvoidNPCs, name) == false then -- 不是敌对NPC
                        local guid = Wow.UnitGUID(obj)
                        if string.find(guid, "Pet") == nil then -- make sure target is not a pet of horde
                            if unitHp <= 10 and unitHp > 0 then
                                table.insert(AggroTable, obj) -- add to aggro list for priority in killing blow
                            else
                                table.insert(targetTable, obj)
                            end
                        end
                    else
                        local isInDangerRange = IsInAggroRange(obj, 10)
                        if isInDangerRange then
                            StatusStr = "KITING_DANGER"
                            Wow.DebugPrint('Kiting Dangerous NPC - ' .. Wow.ObjectName(obj))
                            MoveFacingObject(obj, 1, false) -- 0.2 so to set move far away
                            Sleep(3)
                            PauseWPMovTil = Wow.GetTime() + 10
                        end
                    end
                else
                    if isPlayer and Wow.UnitIsEnemy(obj, "player") and IsTargeting(obj, "player") then
                        PvpTargeted = true
                    end
                end
            end
        end
    end

    -- Iterate thru table containing all targets AT ALL DISTANCE (not just within pullrange)
    local found = false
    local lowestDist = 99999
    if #AggroTable > 0 then
        local lowestHP = 99999
        for i = 1, #AggroTable, 1 do
            local tar = AggroTable[i]
            local unitHp = GetUnitHP(tar)
            local dist = Wow.GetDistanceBetweenObjects(tar, "player")
            if dist < lowestDist then
                lowestDist = dist
            end
            if unitHp < lowestHP and unitHp > 0.0 then
                -- Using pullrange*3 coz is aggrod (we don't want aggrod target which is far to go unchecked)
                if dist <= (PULL_RANGE * 3) then -- tbh should remove this dist check
                    lowestHP = unitHp
                    if keepAttObj == false then
                        AttackObj = tar
                    end
                    found = true
                    -- DbgPrint('Target chosen based on AGGRO')
                end
            end
        end
    else
        for i = 1, #AggroTable, 1 do
            local tar = targetTable[i]
            local unitHp = GetUnitHP(tar)
            local dist = Wow.GetDistanceBetweenObjects(tar, "player")
            if dist < lowestDist and unitHp > 0.0 then
                lowestDist = dist
                if dist <= PULL_RANGE then -- -5 to test stutter step bug
                    if keepAttObj == false then
                        AttackObj = tar
                    end
                    found = true
                    -- DbgPrint('Target chosen based on Proximity')
                end
            end
        end
    end

    -- print(lowestDist)
    if lowestDist > MOUNT_CUT_OFF_DIST then
        -- print('====> dist is too far at '..lowestDist)
        TargetIsFar = true
    else
        -- print('CLOSE :)')
        TargetIsFar = false
    end

    return found
end

function FaceUnit(unit)
    if Wow.UnitExists(unit) then
        local ax, ay, az = Wow.ObjectPosition("player")
        local bx, by, bz = Wow.ObjectPosition(unit)
        local angle = Wow.rad(Wow.atan2(by - ay, bx - ax))
        if angle < 0 then
            return Wow.FaceDirection(Wow.rad(Wow.atan2(by - ay, bx - ax) + 360))
        else
            return Wow.FaceDirection(angle)
        end
    end
end

function GetAggrodUnit()
    -- Gets Lowest Aggrod Unit
    local lowestHPUnit = 101
    local aggrodUnit = nil

    local objCount = Wow.GetObjectCount()
    for i = 1, objCount do
        local obj = Wow.GetObjectWithIndex(i)
        if obj ~= nil then -- and Wow.UnitIsEnemy("player", obj) == true  then
            local targetedGUID = Wow.UnitGUID(Wow.UnitTarget(obj))
            if targetedGUID == Wow.UnitGUID("player") or targetedGUID == Wow.UnitGUID("pet") then
                local unitHP = GetUnitHP(obj)
                if unitHP < lowestHPUnit then
                    lowestHPUnit = unitHP
                    aggrodUnit = obj
                end
            end
        end
    end

    return aggrodUnit
end

function Cast(spellName)
    if Wow.IsCastable(spellName) and Wow.IsSpellInRange(spellName, "target") then
        Wow.CastSpellByName(spellName, false)
        return true
    end
end

InterruptTargetGUID = nil
StopMovingBeforeAttack = true

function HunterRotation()
    HunterBuff = "Aspect of the Hawk"

    local enemyHP = GetUnitHP("target")
    local hp = GetUnitHP("player")
    local enemyName = Wow.ObjectName("target")

    local inCombat = IsInCombat("player")
    StopMovingBeforeAttack = true
    local px, py, pz = Wow.ObjectPosition("player")
    local xx, yy, zz = Wow.ObjectPosition("target")
    DestX = xx
    DestY = yy
    DestZ = zz
    StatusStr = "ATTACK"

    local dist = Wow.GetDistanceBetweenObjects("player", "target")
    local isPlayerTakingAggro = IsTargeting("target", "player")

    local lvlDiff = Wow.UnitLevel("target") - Wow.UnitLevel("player")
    local ammo = Wow.GetItemCount(Hunter:GetAmmoName())

    -- Mend Pet if not being targeted
    if isPlayerTakingAggro == false then
        if MendingPet() then
            Spell = "Mending"
            return
        end
    end

    local targettingPet = IsTargeting("target", "pet")
    -- Movement (Kite or Melee) depending on who is targeted
    if dist <= 12.5 or dist > PULL_RANGE or ammo == 0 then
        if (isPlayerTakingAggro and dist >= 4) or (dist > PULL_RANGE) or (ammo == 0 and dist >= 4) then -- Move Towards mob
            Wow.DebugPrint('Moving into melee range.')
            local div = 3
            if ammo == 0 then
                StopMovingBeforeAttack = false
                Spell = "0 Ammo Move"
                div = 1.5
            end
            MoveFacingObject("target", div, true)
            if ammo == 0 then
                Sleep(1)
            else
                Sleep(0.5)
            end
            return
        elseif KITE and targettingPet and dist < 13 and Wow.GetItemCount(Hunter:GetAmmoName()) > 0 then -- Move away to fire 
            Wow.DebugPrint('Moving away into kiting range [Dist:' .. dist .. ']') -- ??confirm
            MoveFacingObject("target", 0.02, false) -- 0.2 so to set move far away
            local slp = 0.5 + ((13 - dist) / 10);
            Sleep(slp)
            return
        end
    end

    if IsTargeting("target", "player") and dist > 6 and Wow.IsCastable("Intimidation") then
        Spell = "Intimidation"
        Wow.CastSpellByName("Intimidation")
        Sleep(0.3)
        return
    end

    FaceUnit("target")

    if hp < 15 and enemyHP > 15 and inCombat and Wow.IsCastable("Feign Death") and PvpTargeted == false then
        Spell = "Feigning Death at HP " .. hp .. " %"
        Wow.CastSpellByName("Feign Death")
        Sleep(10)
        return
    end

    local bRanged = dist < PULL_RANGE and dist >= 8 and ammo > 0
    if bRanged then
        if Wow.HasDebuff("Hunter's Mark", "target") == false then
            Spell = "Marking"
            Cast("Hunter's Mark")

            if AGGRO_WITH_PET or bRanged == false then
                Wow.RunMacroText("/petattack")
                Wow.RunMacroText("/startattack")
            end

            Sleep(1)
            return
        end

        local aggrCnt = table.getn(AggroTable)
        if inCombat and (lvlDiff > 3 or (hp < 30 and enemyHP > 30) or aggrCnt > 1) then
            if bRanged and Wow.IsCastable("Rapid Fire") then
                Wow.CastSpellByName("Rapid Fire")
                Spell = "Rapid Fire"
                return
            end
            if Wow.IsCastable("Bestial Wrath") then
                Wow.CastSpellByName("Bestial Wrath")
                Spell = "Bestial Wrath"
                return
            end
        end

        local immuneToSS = enemyName:find("Rock") ~= nil or enemyName:find("rock") ~= nil
        if inCombat and immuneToSS == false and Wow.HasDebuff("Serpent Sting", "target") == false then
            if Cast("Serpent Sting") then
                Spell = "Serpent Sing"
                return
            end
        end

        if inCombat and dist < 33 and dist > 10 and isPlayerTakingAggro then
            if Cast("Concussive Shot") then
                Spell = "Concussing"
                return
            end
        end

        if inCombat and Cast("Arcane Shot") then
            Spell = "Arcane Shot"
            return
        end

        Spell = "Arrowing"
        Wow.RunMacroText("/cast !Auto Shot")
        if AGGRO_WITH_PET then
            Wow.RunMacroText("/petattack")
            Wow.RunMacroText("/startattack")
        end
    end

    if dist <= MELEE_RANGE then
        if targettingPet == false then
            if Cast("Disengage") then
                Spell = "Disengage"
                Sleep(0.2)
                return
            end
        end

        if Cast("Mongoose Bite") then
            Spell = "Mongoose Bite"
            Sleep(0.5)
            return
        end

        if (lvlDiff >= 3 or (hp < 30 and enemyHP > 30)) and Wow.IsCastable("Blood Fury") then
            Wow.CastSpellByName("Blood Fury")
            Spell = "Blood Fury [RACIAL]"
            Sleep(1)
            return
        end

        Spell = "MELEE RANGE"
        Wow.RunMacroText("/petattack")
        Wow.RunMacroText("/startattack")

        ----If have no pet
        if Cast("Raptor Strike") then
            Spell = "Raptor Strike"
            Sleep(0.5)
            return
        end
    end
end

ForceStopNextMove = false
PrefFire = false
ForceCS = false
ForceCSAtTime = 0

function Counterspell()
    if ForceCS then
        local csObj = Wow.GetObjectWithGUID(InterruptTargetGUID)
        if csObj == nil or Wow.UnitIsDead(csObj) then
            ForceCSAtTime = 0
            ForceCS = false
        elseif Wow.GetDistanceBetweenObjects("player", csObj) < 32 and Wow.GetTime() > ForceCSAtTime then
            if Wow.IsCastable("Counterspell") then
                Spell = "Counterspell"
                Wow.SpellStopCasting()
                Wow.CastSpellByName("Counterspell", false)
                Sleep(0.333)
                ForceCSAtTime = 0
                ForceCS = false
            end
        end
    end
end

function IsPolymorphUsed()
    local objCount = Wow.GetObjectCount()
    for i = 1, objCount do
        local obj = Wow.GetObjectWithIndex(i)
        if obj ~= nil then
            if Wow.UnitIsEnemy("player", obj) and Wow.UnitIsDead(obj) == false then
                if Wow.HasDebuff("Polymorph", obj) then
                    return true
                end
            end
        end
    end
    return false
end

function CanPoly(obj)
    local cType = Wow.UnitCreatureType(obj)
    return cType == "Beast" or cType == "Humanoid" or cType == "Critter"
end

DecurseIgnoreTill = 0

function Decurse()
    if Wow.GetTime() < DecurseIgnoreTill then
        return false
    end

    for i = 1, 40 do
        local debuff = Wow.UnitDebuff("player", i)
        if debuff == nil then
            return false
        elseif debuff:find("Curse") or debuff:find("curse") then
            Wow.CastSpellByName("Remove Lesser Curse")
            DecurseIgnoreTill = Wow.GetTime() + 10
            return true
        end
    end
end

IgnorePolyTill = 0

function MageRotation()
    local inCombat = IsInCombat("player")

    local tX, tY, tZ = Wow.ObjectPosition("target")
    if ForceStopNextMove then -- PRECAUTION when kiting
        ForceStopNextMove = false
        Wow.SendKey(83, 123)
    end
    DestX = tX
    DestY = tY
    DestZ = tZ
    Spell = ""
    StatusStr = "ATTACK"

    if Decurse() then
        return
    end

    local dist = Wow.GetDistanceBetweenObjects("player", "target")
    if dist > PULL_RANGE + 1 or (inCombat and dist > PULL_RANGE) then
        Wow.DebugPrint('Cast Distance = TOOLARGE @' .. dist)
        MoveFacingObject("target", 2, true)
        Spell = "Moving Within Range"
        Sleep(0.5)
        return
    end

    if dist < PULL_RANGE + 5 then
        local enemyHP = GetUnitHP("target")
        local hp = GetUnitHP("player")
        local mana = GetUnitMana("player")

        Counterspell()

        -- Polymorph when 1v2+
        local aggrCount = table.getn(AggroTable)
        local isPolyied = IsPolymorphUsed()
        if aggrCount > 1 and Wow.IsCastable("Polymorph") and isPolyied == false and Wow.GetTime() > IgnorePolyTill then
            Wow.DebugPrint('Polymode: 1v' .. aggrCount)
            local closest = 9999
            local polyTarget = nil
            local closestTar = nil
            local highestHP = 1
            for i = 1, aggrCount, 1 do
                local tar = AggroTable[i]
                local tHP = GetUnitHP(tar)
                Wow.DebugPrint(' --> ' .. tHP)
                local tdist = Wow.GetDistanceBetweenObjects("player", tar)
                if CanPoly(tar) and tHP > 40 then
                    if tHP > highestHP and tdist < 30 then
                        highestHP = tHP
                        polyTarget = tar
                    end
                    if tdist < closest then
                        closest = tdist
                        closestTar = tar
                    end
                end
            end

            if closestTar ~= nil and closest > 30 then
                Wow.DebugPrint('Moving into polymorph range as closest is' .. math.ceil(closest) .. 'y away!')
                MoveFacingObject(closestTar, 2, true)
                Sleep(0.5)
                return
            end

            if polyTarget ~= nil then
                Wow.DebugPrint('Polying Target at ' .. GetUnitHP(polyTarget))
                Wow.TargetUnit(polyTarget)
                Spell = "Polymorph"
                Wow.CastSpellByName("Polymorph", false)
                IgnorePolyTill = Wow.GetTime() + 2
                Sleep(0.3)
                return
            end
        end

        -- Bandage
        if isPolyied and aggrCount == 0 and hp < 70 then
            local bandage = GetBandageName()
            if bandage ~= "" and IsItemUsable(bandage) then
                Wow.DebugPrint('Using ' .. bandage)
                Wow.RunMacroText("/use " .. bandage)
                Sleep(1.1)
                return
            end
        end

        -- Evocation
        if isPolyied and mana < 35 and Wow.IsCastable("Evocation") then
            Wow.CastSpellByName("Evocation")
            Sleep(4.2)
        end

        -- Kite/Blink
        if KITE and dist <= 7 and Wow.HasDebuff("Frost Nova", "target") then
            MoveFacingObject("target", 0.01, false) -- 0.01 div so as to set move marker far in case tar is close
            ForceStopNextMove = true
            Spell = "Kiting"
            -- if isCastable("Blink") then
            -- DbgPrint("Blinking!")
            -- Wow.CastSpellByName("Blink")
            -- else
            Sleep(0.666)
            -- end
        else
            -- Evocation
            if mana < 10 and enemyHP > 6 and Wow.IsCastable("Evocation") and HasManaGem() == false then
                Wow.CastSpellByName("Evocation")
                Spell = "Evocation"
                if hp > 75 then
                    Sleep(6.1) -- almost full duration
                elseif hp > 50 then
                    Sleep(4.1)
                else
                    Sleep(2.1)
                end
                return
            elseif mana > 40 or hp < 20 then
                ApplyBuff("Ice Barrier")
            end
        end

        -- Ice Block
        if GetUnitHP("player") < 15 and inCombat and Wow.IsCastable("Ice Block") then
            Spell = "Blocking at HP " .. GetUnitHP("player") .. " %"
            Wow.CastSpellByName("Ice Block")
            Sleep(9.3)
            return
        end

        -- Standard Rotation
        FaceUnit("target")

        if enemyHP > WAND_BELOW then -- 0 condition is to debug :/
            -- Cone of Cold/Nova
            if inCombat and dist < 10 and isPolyied == false then
                -- ! Add Feature to stop ONLY if current cast has long time to fire
                if Wow.IsCastable("Frost Nova") then
                    Spell = "Nova"
                    Wow.SpellStopCasting()
                    Wow.CastSpellByName("Frost Nova(Rank 1)")
                    return
                end
                if Wow.IsCastable("Cone of Cold") then
                    Spell = "CoC"
                    -- Wow.SpellStopCasting()
                    Wow.CastSpellByName("Cone of Cold")
                    return
                end
            end

            -- Fire Blast
            if inCombat and dist <= 19.5 and Wow.IsCastable("Fire Blast") then
                Spell = "Fireblast"
                Wow.CastSpellByName("Fire Blast", false)
                return
            end

            -- Frostbolt/Fireball Filler
            if PrefFire == false and Wow.IsCastable("Frostbolt") then
                Spell = "Frostbolt"
                Wow.CastSpellByName("Frostbolt", false)
                Sleep(0.25)
                return
            elseif Wow.IsCastable("Fireball") then
                Spell = "Fireball"
                Wow.CastSpellByName("Fireball", false)
                Sleep(0.5)
                return
            end
        else -- Enemy is SUPER LOW
            if hp < 20 then -- I am super low too so rush kill w/o wand
                if inCombat and dist < 20 and Wow.IsCastable("Fire Blast") then
                    Spell = "Fireblast LOW/CRITICAL"
                    Wow.CastSpellByName("Fire Blast", false)
                    return
                end
                if inCombat and dist < 10 and Wow.IsCastable("Frost Nova") then
                    Spell = "Nova LOW/CRITICAL"
                    Wow.SpellStopCasting()
                    Wow.CastSpellByName("Frost Nova(Rank 1)")
                    return
                end
                if inCombat and dist < 10 and Wow.IsCastable("Cone of Cold") and isPolyied == false then
                    Spell = "CoC LOW/Critical"
                    Wow.SpellStopCasting()
                    Wow.CastSpellByName("Cone of Cold")
                    return
                end
            end

            if dist > 29 then
                Spell = "Moving to Wand LOW"
                Wow.DebugPrint('Moving into Wanding Distance')
                MoveFacingObject("target", 8, true)
                Sleep(0.25)
                return
            end

            Spell = "Wanding LOW"
            -- Wand and player not critical
            Wow.SpellStopCasting()
            -- print('LOW --> Wanding! '..enemyHP..' hp')
            Wow.RunMacroText("/cast !Shoot")
            Sleep(1.2)
            return
        end

        -- If No Mana  => WAND
        if mana < 5 then
            if dist > 29 then
                Spell = "Moving to Wand OOM"
                Wow.DebugPrint('Moving into Wanding Distance')
                MoveFacingObject("target", 8, true)
                Sleep(0.25)
                return
            end
            Wow.SpellStopCasting()
            -- print('OOM --> Wanding! '..mana..' mana')
            Spell = "Wanding OOM"
            Wow.RunMacroText("/cast !Shoot")
            Sleep(1.2)
            return
        end
    else
        Spell = "TOO FAR"
        return
    end

    Spell = "NOTHING"
    if Wow.UnitCastID("player") == 0 and GetUnitHP("target") > WAND_BELOW then -- Wanding bug were isOnCD always returns true when wanding unless scripts ticks at perfect time
        local usable, nomana = Wow.IsUsableSpell("Frostbolt")
        if usable and nomana == false then
            Spell = "Frostbolt_NOTHING"
            Wow.CastSpellByName("Frostbolt", false)
            Sleep(0.25)
            return
        end
    end
end

-- local autoShotOn = false
function Attack(obj)
    Potion()

    if Wow.HasAura("player", "First Aid") or (Wow.IsMage() and Wow.HasAura("player", "Evocation")) then
        Sleep(0.25)
        return
    end

    local isEating = Wow.HasAura("player", "Food")
    local isDrinking = Wow.HasAura("player", "Drink")
    if isEating or isDrinking then
        Wow.SendKey(' ')
    end

    if obj == nil then
        return
    end

    if obj ~= nil then
        Wow.TargetUnit(obj)
    end
    if Wow.UnitIsDead("target") then
        return
    elseif AggrodToAnotherPlayer("target") then
        Wow.DebugPrint(Wow.ObjectName("target") .. " at " .. GetUnitHP("target") .. " is tapped by another player...")
        Wow.DebugPrint(" ==> FORCING MOVEMENT");
        PulseMovement()
        PathEndCheck()
        return
    end

    if IsMoving("player") and StopMovingBeforeAttack then -- Stop Movement
        Wow.SendKey(83, 123)
    end

    if Wow.UnitExists("target") == false then
        return
    end

    if Wow.IsMounted() then
        Wow.Dismount()
    end

    if Wow.IsHunter() then
        HunterRotation()
    elseif Wow.IsMage() then
        MageRotation()
    end
end

OpenArr = {false, false, false, false, false, false, false, false, false}

function Random()
    if IsInCombat("player") then
        return
    end

    -- Reset Windows
    if OpenArr[1] then
        OpenArr[1] = false
        Wow.SendKey(79)
        return
    end
    if OpenArr[2] then
        OpenArr[2] = false
        Wow.SendKey(74)
        return
    end
    if OpenArr[3] then
        OpenArr[3] = false
        Wow.SendKey(76)
        return
    end
    if OpenArr[4] then
        OpenArr[4] = false
        Wow.SendKey(66)
        return
    end
    if OpenArr[5] then
        OpenArr[5] = false
        Wow.SendKey(80)
        return
    end
    if OpenArr[6] then
        OpenArr[6] = false
        Wow.SendKey(67)
        return
    end
    if OpenArr[7] then
        OpenArr[7] = false
        Wow.SendKey(78)
        return
    end

    local rnd = math.random(1, 200)
    if rnd >= 1 and rnd <= 10 then
        if Wow.UnitCastID("player") == 0 then
            Wow.SendKey(' ')
        end
    elseif rnd == 11 then
        Wow.RunMacroText("/yawn")
    elseif rnd == 12 then
        Wow.RunMacroText("/cheer")
    elseif rnd >= 13 and rnd <= 15 then
        Wow.RunMacroText("/train")
    elseif rnd >= 16 and rnd <= 20 then
        Wow.SendKey(79)
        OpenArr[1] = true
    elseif rnd >= 21 and rnd <= 23 then
        Wow.SendKey(74)
        OpenArr[2] = true
    elseif rnd >= 26 and rnd <= 28 then
        Wow.SendKey(76)
        OpenArr[3] = true
    elseif rnd >= 31 and rnd <= 35 then
        Wow.SendKey(66)
        OpenArr[4] = true
    elseif rnd >= 36 and rnd <= 38 then
        Wow.SendKey(80)
        OpenArr[5] = true
    elseif rnd >= 39 and rnd <= 42 then
        Wow.SendKey(67)
        OpenArr[6] = true
    elseif rnd >= 43 and rnd <= 44 then
        Wow.SendKey(78)
        OpenArr[7] = true
    elseif rnd > 56 and rnd < 70 then
        if Wow.UnitCastID("player") == 0 then
            Wow.SendKey(' ')
        end
    end
end

-- https://wowwiki.fandom.com/wiki/Aggro_radius
function IsSafeToLoot(lootObj)
    if SAFE_LOOTING == false then
        return true
    end

    local playerLevel = Wow.UnitLevel("player")
    local objCount = Wow.GetObjectCount()
    for i = 1, objCount do
        local obj = Wow.GetObjectWithIndex(i)
        if obj ~= nil then
            if Wow.UnitIsEnemy("player", obj) and Wow.UnitIsDead(obj) == false then
                local unitLevel = Wow.UnitLevel(obj)
                local distLootAggroObj = Wow.GetDistanceBetweenObjects(lootObj, obj)
                local aggroRad = (unitLevel - playerLevel) + 25 -- suppost +20 imma to be safe +5
                if distLootAggroObj < aggroRad then
                    Wow.DebugPrint('Not looting ' .. Wow.ObjectName(lootObj) .. ' as it is ' .. math.ceil(distLootAggroObj) .. 'y within hostile ' .. Wow.ObjectName(obj))
                    return false
                end
            end
        end
    end

    return true
end

PLAYER_NAME = Wow.ObjectName("player")
SkinningTime = 0
IgnoreSkinningTill = 0

function Skinning()
    if HasInInventory("Skinning Knife") == false then
        return false
    end
    if SkinningTime > 12 then
        Wow.DebugPrint("Stuck Skinning --> SKIPPING")
        SkinningTime = 0
        IgnoreSkinningTill = Wow.GetTime() + 30
        return false
    end

    -- https://classic.wowhead.com/spells/name:skinning
    local cID = Wow.UnitCastID("player")
    if cID == 10768 or cID == 10769 or cID == 8617 or cID == 8613 or cID == 8618 then -- if is skinning
        return true
    end

    if IgnoreSkinningTill > Wow.GetTime() then
        return false
    end

    local freeSlots = GetFreeSlots()
    if freeSlots <= 0 then
        return false
    end

    local closestDist = 999999
    local skinObj = nil

    local px, py, pz = Wow.ObjectPosition("player")

    local objCount = Wow.GetObjectCount()
    for i = 1, objCount do
        local obj = Wow.GetObjectWithIndex(i)
        if obj ~= nil then
            local name = Wow.ObjectName(obj)
            if name ~= "Campfire" and name ~= PLAYER_NAME and name:find("Rune of") == nil then
                local ox, oy, oz = Wow.ObjectPosition(obj)
                if Wow.UnitCanBeSkinned(obj) == true and TraceLine(px, py, pz + 2.5, ox, oy, oz + 2.5, LOST_FLAGS) == nil and Wow.UnitIsEnemy("player", obj) then
                    local dist = math.sqrt(((px - ox) ^ 2) + ((py - oy) ^ 2) + ((pz - oz) ^ 2))
                    if dist < closestDist and IsSafeToLoot(obj) then
                        closestDist = dist
                        skinObj = obj
                    end
                end
            end
        end
    end

    if skinObj ~= nil and closestDist < MAX_LOOT_DIST then
        Wow.DebugPrint('Skinning ' .. Wow.ObjectName(skinObj) .. '!!!')
        local objName = Wow.ObjectName(skinObj)
        Spell = objName

        local lootX, lootY, lootZ = Wow.ObjectPosition(skinObj)
        Wow.MoveTo(lootX, lootY, lootZ)

        local dist = Wow.GetDistanceBetweenObjects(skinObj, "player")
        if dist <= 5 then
            DismountCheck()
            Wow.InteractUnit(skinObj)
        end

        StatusStr = "SKINNING"
        ClearTargetDrawTables()
        if closestDist <= 3 and IsMoving("player") == false then
            SkinningTime = SkinningTime + 1.1 + PULSE_DELAY
            Sleep(1.1)
        else
            SkinningTime = SkinningTime + PULSE_DELAY
        end
        return true
    end

    SkinningTime = 0
    return false
end

LootingTime = 0
IgnoreLootingTill = 0

function Looting()
    if Wow.UnitCastID("player") ~= 0 then
        return false
    end
    local freeSlots = GetFreeSlots()
    if freeSlots <= 0 then
        return false
    end

    if LootingTime > 6 then
        Wow.DebugPrint("Stuck Looting --> SKIPPING")
        LootingTime = 0
        IgnoreLootingTill = Wow.GetTime() + 30
    end

    if IgnoreLootingTill > Wow.GetTime() then
        return false
    end

    local closestDist = 999999
    local lootObj = nil
    local lootCount = 0

    local px, py, pz = Wow.ObjectPosition("player")

    local objCount = Wow.GetObjectCount()
    for i = 1, objCount do
        local obj = Wow.GetObjectWithIndex(i)
        if obj ~= nil then
            local ox, oy, oz = Wow.ObjectPosition(obj)
            if Wow.UnitIsDead(obj) and Wow.UnitCanBeLooted(obj) and TraceLine(px, py, pz + 2.5, ox, oy, oz + 2.5, LOST_FLAGS) == nil then
                lootCount = lootCount + 1

                local dist = math.sqrt(((px - ox) ^ 2) + ((py - oy) ^ 2) + ((pz - oz) ^ 2))
                if dist < closestDist and IsSafeToLoot(obj) then
                    closestDist = dist
                    lootObj = obj
                end
            end
        end
    end

    if lootObj ~= nil and closestDist < MAX_LOOT_DIST then
        local objName = Wow.ObjectName(lootObj)
        Wow.DebugPrint('Looting ' .. objName .. '!!!')
        Spell = objName

        local lootX, lootY, lootZ = Wow.ObjectPosition(lootObj)
        Wow.MoveTo(lootX, lootY, lootZ)

        local dist = Wow.GetDistanceBetweenObjects(lootObj, "player")
        if dist <= 5 then
            DismountCheck()
            Wow.InteractUnit(lootObj)
        end

        StatusStr = "LOOTING"
        Sleep(1)
        LootingTime = LootingTime + 0.5 + PULSE_DELAY
        return true
    end

    LootingTime = 0
    return false
end

function DeletePeskyItems()
    for i = 1, #DeleteItems, 1 do
        local itemName = DeleteItems[i][1]
        local bag, slot
        local total = 0
        for bag = 0, 4 do
            for slot = 0, Wow.GetContainerNumSlots(bag) do
                local link = Wow.GetContainerItemLink(bag, slot)
                if link then
                    local sName, _, _, _, _, _, _, _ = Wow.GetItemInfo(link)
                    if sName == itemName then
                        Wow.DebugPrint('- DELETING ' .. itemName .. '!!!')
                        Wow.PickupContainerItem(bag, slot)
                        Wow.DeleteCursorItem()
                    end
                end
            end
        end
    end
end

function BuyStuff()
    if Wow.IsMage() then
        return
    end

    local drinksToHave = 140
    Wow.DebugPrint('Buying Drinks')
    local drinkSlot = GetVendorSlot(Drinks[2])
    if drinkSlot ~= -1 then
        local drinkCount = Wow.GetItemCount(Drinks[2])
        if drinkCount >= drinksToHave then
            return
        end

        local needToBuy = drinksToHave - drinkCount;
        Wow.DebugPrint('Buying ' .. needToBuy .. ' ' .. Drinks[2]);
        local div = needToBuy / 5

        for i = 1, div do
            Wow.BuyMerchantItem(drinkSlot);
        end
        Sleep(1) -- ammo takes a ton of time to appear	
    end

    Hunter:BuyAmmo()
end

SellTick = 0
CanMail = false

function SellAndBuyShit()
    -- Delete Shit
    DeletePeskyItems()

    -- Talk To Vendor
    if TalkedToVendor == false then
        local objCount = Wow.GetObjectCount()
        for i = 1, objCount do
            local obj = Wow.GetObjectWithIndex(i)
            if Wow.ObjectName(obj) == VendorName then
                Wow.DebugPrint('Selling to ' .. VendorName)
                Wow.InteractUnit(VendorName)
                Sleep(1.5)
            end
        end
        -- merchant_show event will handle this
        return
    end

    -- SELL ALGO
    if TalkedToVendor == true then
        Wow.DebugPrint('Clearing Bags...')
        local bag, slot
        local total = 0
        for bag = 0, 4 do
            for slot = 0, Wow.GetContainerNumSlots(bag) do
                local link = Wow.GetContainerItemLink(bag, slot)
                if link then
                    local sName, sLink, iRarity, iLevel, iMinLevel, sType, sSubType, iStackCount = Wow.GetItemInfo(link)
                    if ArrayContains(ForcedToSell, sName) then
                        Wow.DebugPrint('Force-Selling: ' .. sName)
                        Wow.UseContainerItem(bag, slot)
                    elseif Wow.IsHunter() and (sName == Hunter:GetAmmoName() or ArrayContains(PetFoods, sName)) then
                        -- DbgPrint('Keeping [Hunter Ammo/PetFood]: '..sName)
                    elseif sSubType == "Bag" or (Wow.IsHunter() and (sSubType == "Quiver" or sSubType == "Ammo Pouch")) then
                        -- Bug where last Bag is perceived as item in other bags for selling :/
                    elseif sName:find("Potion") ~= nil or sName:find("Bandage") ~= nil then
                        -- DbgPrint('Keeping [Potion]: '..sName)
                    elseif sName == "Hearthstone" or sType == "Projectile" or iRarity >= 3 then
                        -- DbgPrint('Keeping [HardCoded]: '..sName)
                    elseif iRarity >= 2 then -- and (sSubType == "Bows" or sSubType == "Guns" or sSubType == "Two-Handed Swords" or sSubType == "Leather") then
                        -- DbgPrint('Keeping [Rarity]: '..sName)
                    elseif ArrayContains(ToKeep, sName) or ArrayContains(ToMail, sName) then
                        -- DbgPrint('Keeping [ToKeepList]: '..sName)
                    elseif sName == MOUNT_NAME then
                        -- DbgPrint('Keeping [Mount]: '..sName)
                    elseif ArrayContains(Foods, sName) or ArrayContains(Drinks, sName) then
                        -- DbgPrint('Keeping [RegenConsumable]: '..sName)
                    else
                        if MAIL_ENABLED and iRarity < 1 then -- since we are mailing, just sell junk
                            Wow.DebugPrint('Selling [Junk]: ' .. sName)
                            Wow.UseContainerItem(bag, slot)
                        else
                            if MAIL_ENABLED == false then -- since we are not mailing sell junk + whites
                                Wow.DebugPrint('Selling [Space]: ' .. sName)
                                Wow.UseContainerItem(bag, slot)
                            end
                        end
                    end
                end
            end
        end

        BuyStuff()
        VendorPathIdx = #VendorPoints - 1
        SellTick = SellTick + 1

        if Wow.CanMerchantRepair() then
            Wow.RepairAllItems()
        end
        if SellTick == 5 then
            SellComplete = true
            CanMail = true
            SellTick = 0
        end
        Sleep(6)
    end
end

LibDraw = LibStub("LibDraw-1.0")
LibDraw.SetWidth(30)

function ResetVariables()
    Wow.DebugPrint("Resetting Vars!!!")
    GoingToVendor = false
    AtVendor = false
    SellComplete = false
    TalkedToVendor = false
    AtStartAfterVendor = false
end

Frame:RegisterEvent("COMBAT_LOG_EVENT_UNFILTERED")
Frame:RegisterEvent("MERCHANT_SHOW")

Frame:SetScript("OnEvent", function(self, event)
    if event == "MERCHANT_SHOW" then
        TalkedToVendor = true
        Wow.DebugPrint("Vendor Window Open!!!")
    elseif event == "COMBAT_LOG_EVENT_UNFILTERED" and IsInCombat("player") then
        local timestamp, subevent, _, sourceGUID, sourceName, sourceFlags, sourceRaidFlags, destGUID, destName, destFlags, destRaidFlags = Wow.CombatLogGetCurrentEventInfo()
        Wow.DebugPrint(subevent)
        Wow.DebugPrint(sourceGUID)
        if subevent == "SPELL_CAST_START" then
            local obj = Wow.GetObjectWithGUID(sourceGUID)
            if AggrodToAnotherPlayer(obj) == false then
                InterruptTargetGUID = sourceGUID
                if Wow.IsMage() then
                    ForceCS = true
                    ForceCSAtTime = Wow.GetTime() + CS_DELAY
                end
            end
        end
    end
end)

DebugMessage = ""

function Draw()
    if DRAW_ENABLED and CanDraw() then
        LibDraw.clearCanvas()
        local pX, pY, pZ = Wow.ObjectPosition("player")

        -- Draw Status String
        if DRAW_TEXT_ENABLED then
            -- Debug message
            if DebugMessage ~= "" then
                local debugMessage = DebugMessage
                if Spell ~= "" and StatusStr == "ATTACK" or StatusStr == "SKINNING" then
                    debugMessage = debugMessage .. " [" .. Spell .. "]"
                end
                LibDraw.SetColorRaw(0, 0, 1, 1)
                LibDraw.Text(debugMessage, "GameFontRedSmall", pX, pY, pZ + 4)
            end

            -- 各种状态
            LibDraw.SetColorRaw(1, 1, 1, 1)
            if StatusStr == "ATTACK" then -- Attacking
                local str = 'Attacking...'
                if AttackObj ~= nil then
                    local odist = Wow.GetDistanceBetweenObjects("player", AttackObj)
                    odist = math.ceil(odist)
                    str = Wow.ObjectName(AttackObj) .. ' [' .. GetUnitHP(AttackObj) .. '%] {' .. odist .. 'y}'
                end
                LibDraw.Text(str, "GameFontNormal", pX, pY, pZ + 3)
            elseif StatusStr == "WP" then -- Searching mobs
                LibDraw.Text('Searching Mobs...', "GameFontNormal", pX, pY, pZ + 3)
            elseif StatusStr == "RECOVERING" then -- Recovering
                LibDraw.Text('Recovering...', "GameFontNormal", pX, pY, pZ + 3)
            elseif StatusStr == "LOOTING" then -- Looting
                LibDraw.Text('Looting...', "GameFontNormal", pX, pY, pZ + 3)
            elseif StatusStr == "SKINNING" then -- Skinning
                LibDraw.Text('Skinning...', "GameFontNormal", pX, pY, pZ + 3)
            elseif StatusStr == "CORPSE_RUN" then -- Corpse run
                LibDraw.Text('Corpse Run...', "GameFontNormal", pX, pY, pZ + 3)
            elseif StatusStr == "VENDOR" then -- Vender
                if SellComplete then
                    LibDraw.Text('Going to Start...', "GameFontNormal", pX, pY, pZ + 3)
                else
                    LibDraw.Text('Going to Sell...', "GameFontNormal", pX, pY, pZ + 3)
                end
            elseif StatusStr == "DEAD" then -- Dead
                LibDraw.SetColorRaw(1, 0, 0, 1)
                LibDraw.Text('DEAD', "GameFontNormal", pX, pY, pZ + 3)
            elseif StatusStr == "KITING_DANGER" then -- Avoiding dangerous NPC
                LibDraw.SetColorRaw(1, 0, 0, 1)
                LibDraw.Text('Avoiding Dangerous NPC', "GameFontNormal", pX, pY, pZ + 3)
            end
        end

        -- Main Line Draw
        if DRAW_WP_ENABLED and DestX ~= nil and DestY ~= nil and DestZ ~= nil then
            LibDraw.SetColorRaw(0, 0, 1, 1)
            LibDraw.Line(pX, pY, pZ + 0.2, DestX, DestY, DestZ + 0.2)
        end

        -- 敌对玩家
        for i = 1, table.getn(EnemyPlayers), 1 do
            local pt = EnemyPlayers[i]
            local enemyLevel = pt[4]
            if enemyLevel == nil then
                enemyLevel = 60
            end
            local levelDiff = enemyLevel - Wow.UnitLevel("player")

            if levelDiff > 0 then
                LibDraw.SetColorRaw(1, 0, 0, 1)
                LibDraw.Text('ENEMY {+' .. levelDiff .. '}', "GameFontNormal", pt[1], pt[2], pt[3] + 2)
            else
                LibDraw.SetColorRaw(1, 0.65, 0, 1)
                LibDraw.Text('ENEMY {' .. levelDiff .. '}', "GameFontNormal", pt[1], pt[2], pt[3] + 2)
            end
        end

        -- 敌对NPC
        LibDraw.SetColorRaw(1, 1, 1, 1)
        for i = 1, table.getn(EnemyNPCs), 1 do
            local pt = EnemyNPCs[i]
            LibDraw.Text('[' .. pt[4] .. ']', "GameFontRedSmall", pt[1], pt[2], pt[3] + 2)
        end

        -- Draw Main Route
        if DRAW_WP_ENABLED then
            LibDraw.SetColorRaw(0, 1, 0, 1)
            local beforePT = nil
            for i = 1, #Waypoints, 1 do
                local newPT = Waypoints[i]
                if newPT ~= nil then
                    if beforePT ~= nil then
                        LibDraw.Line(beforePT[1], beforePT[2], beforePT[3], newPT[1], newPT[2], newPT[3])
                    end
                    beforePT = newPT
                end
            end

            -- Draw Vendor Route
            if #VendorPoints > 1 then
                local startVendorPT = VendorPoints[1]
                local endVendorPT = VendorPoints[#VendorPoints]
                if startVendorPT ~= nil then
                    LibDraw.SetColorRaw(0.25, 0.5, 0.75, 1)
                    LibDraw.Circle(startVendorPT[1], startVendorPT[2], startVendorPT[3], 2)
                    LibDraw.Text('Vendor Route', "GameFontRedSmall", startVendorPT[1], startVendorPT[2], startVendorPT[3] + 1)
                    LibDraw.Text('Vendor', "GameFontRedSmall", endVendorPT[1], endVendorPT[2], endVendorPT[3] + 1)

                    beforePT = nil
                    LibDraw.SetColorRaw(1, 1, 1, 1)
                    for i = 1, #VendorPoints, 1 do
                        local newPT = VendorPoints[i]
                        if newPT ~= nil then
                            if beforePT ~= nil then
                                LibDraw.Line(beforePT[1], beforePT[2], beforePT[3], newPT[1], newPT[2], newPT[3])
                            end
                            beforePT = newPT
                        end
                    end
                end
            end
        end
    end
end

function DeadCheck()
    if Wow.UnitIsDead("player") then
        Wow.WriteFile("/Log/Dead.txt", 'Dead at time: ' .. Wow.GetTime(), false)
        Resurrect()
    end
end

function Resurrect()
    if RESURRECT_ENABLED and Wow.UnitIsDeadOrGhost("player") then
        Wow.DebugPrint("Running Resurrect Script")
        local exitMacro = Wow.ReadFile('Resurrect.lua')
        Wow.RunMacroText(exitMacro)
        Exit('Resurrect')
    end
end

function OpenShit()
    local bag, slot
    local total = 0
    for bag = 0, 4 do
        for slot = 0, Wow.GetContainerNumSlots(bag) do
            local link = Wow.GetContainerItemLink(bag, slot)
            if link then
                local sName, _, _, _, _, _, _, _ = Wow.GetItemInfo(link)
                if ArrayContains(OpenInBags, sName) then
                    Wow.DebugPrint("Opening " .. sName)
                    Wow.UseContainerItem(bag, slot)
                end
            end
        end
    end
end

function AmIFoccussed()
    local bKawardCheck = true
    for i = 1, Wow.GetObjectCount() do
        local obj = Wow.GetObjectWithIndex(i)
        if Wow.UnitIsDead(obj) == false and Wow.UnitIsPlayer(obj) == false then
            local focussed = IsTargeting(obj, "player")
            if Wow.IsHunter() and focussed == false then
                focussed = IsTargeting(obj, "pet")
            end
            if IsInCombat(obj) and Wow.UnitCanAttack("player", obj) then
                if focussed or (Wow.IsMage() and Wow.HasDebuff("Frost Nova", obj)) then
                    -- Unit stops targetting when nova'd
                    return true
                else
                    if bKawardCheck then -- Some kaward mobs stop targetting you despite having 'aggro'
                        local hp = GetUnitHP(obj)
                        if hp <= 10 then
                            return true
                        end
                    end
                end
            end
        end
    end

    return false
end

MountTries = 0
MountTimeout = 0

function MountUp()
    if MountTimeout > Wow.GetTime() then
        return false -- do not mount (indoor bug)
    end

    if MountTries >= 3 then
        MountTries = 0
        MountTimeout = Wow.GetTime() + 5
    end

    local combat = IsInCombat("player")
    local indoors = Wow.IsIndoors()
    if indoors and combat == false then
        MountTries = 0
        return false -- do not mount
    end

    if combat == false and Wow.IsMounted() == false and indoors == false and HasMount() then
        if IsMoving("player") then
            Wow.SendKey(83, 222)
        end
        Wow.RunMacroText("/use " .. MOUNT_NAME)
        StallBuffUp = Wow.GetTime() + 8
        MountTries = MountTries + 1
        -- print(mountTries)
        Sleep(1)
        return true
    end

    MountTries = 0
    return false
end

Ttt = Wow.GetTime()
TttTick = 10

function IsNotVendorPathing()
    return GoingToVendor == false and AtVendor == false and SellComplete == false and TalkedToVendor == false and AtStartAfterVendor == false
end

function ResurrectPulse()
    for i = 1, Wow.GetObjectCount() do
        local object = Wow.GetObjectWithIndex(i)
        if Wow.ObjectName(object) == Wow.ObjectName("player") and Wow.UnitIsCorpse(object) then
            if Wow.GetDistanceBetweenObjects("player", object) < 35 then
                if Wow.GetCorpseRecoveryDelay() <= 0 then
                    if PositionAggroCount() >= 1 then
                        Sleep(5)
                        return false
                    end
                    Wow.RetrieveCorpse()
                    return true
                else
                    Sleep(5)
                    return true
                end
            end
        end
    end

    return false
end

-- OnUpdate
DeadTime = 0

DoBotStuff = function(self, elapsed)
    Draw()

    -- 还没到pulse时间
    if CanPulse() == false then
        return
    end

    DeadCheck() -- 会调用Exit()

    -- Resurrect
    if Wow.UnitIsDeadOrGhost("player") then
        if DeadTime > 600 then
            Wow.WriteFile("/Log/Terminate.txt", 'Stuck Dead!', false)
            Wow.RunMacroText(".dc")
        end
        -- AcceptResurrect()
        StatusStr = "CORPSE_RUN"
        DeadTime = DeadTime + PULSE_DELAY
        if ResurrectPulse() == false then
            PulseMovement()
            PathEndCheck()
        end
        return
    else
        DeadTime = 0
    end

    -- Main
    if CheckVitals() then
        DebugMessage = "VITALS_OK"
        if Wow.IsMounted() then
            ProximalTolerance = PROXIMAL_TOLERANCE * 2
        else
            ProximalTolerance = PROXIMAL_TOLERANCE
        end

        local inCombat = IsInCombat("player")
        if inCombat and CombatTime < 90 and (CLEAR_VENDOR_PATH or (CLEAR_VENDOR_PATH == false and Wow.IsMounted() == false and IsNotVendorPathing())) then
            if AmIFoccussed() or (Wow.IsMage() and IsPolymorphUsed()) then -- Without this it will go too HAM because of InCombat remains a bit after fight ends w/o time to recover			
                DebugMessage = "ATTACK_1"
                FindAttackableUnit()
                Attack(AttackObj)
            end
            CombatTime = CombatTime + (CanPulseAt - Wow.GetTime())
        else
            -- ::Resume::
            if Wow.GetTime() - Ttt > TttTick then
                if DC_ON_ITEM_BREAK and GetLowestDurability() <= 1 then
                    Wow.WriteFile("Log/Terminate.txt", 'Item Break...', false)
                    Wow.RunMacroText(".dc")
                end
                DebugMessage = "10s_TIMER_TICK"
                OpenShit()

                if AtVendor == false and SellComplete == false and TalkedToVendor == false and AtStartAfterVendor == false then
                    DeletePeskyItems()
                    Random()
                end
                Ttt = Wow.GetTime()
                TttTick = math.random(10, 20)
            end
            CombatTime = 0

            if GoingToVendor == false then
                EmptyBagsSetup()
            end

            if GoingToVendor and AtVendor == false then
                if CLEAR_VENDOR_PATH and FindAttackableUnit() then
                    DebugMessage = "TO_VENDOR_ATTACKING"
                    Attack(AttackObj)
                else
                    -- MountUp just checks if it needs to Mount, if not (walking or already mounted) WILL RETURN FALSE
                    if MountUp() == false then
                        DebugMessage = "VENDOR_PATH"
                        if LOOT_ON_VENDOR_PATH == false then
                            VendorPath(true)
                        else
                            if Skinning() == false and Looting() == false then
                                VendorPath(true)
                            end
                        end
                    end
                end
            elseif AtVendor and SellComplete == false then  -- 卖东西
                DebugMessage = "SELLING"
                SellAndBuyShit()
            elseif SellComplete and AtStartAfterVendor == false then    -- 邮寄东西
                if MAIL_ENABLED and CanMail then
                    local exitMacro = Wow.ReadFile('Mail.lua')
                    Wow.DebugPrint("Running Mail Script!")
                    Wow.RunMacroText(exitMacro)
                    Exit('Mail')
                end

                if CLEAR_VENDOR_PATH and FindAttackableUnit() then
                    DebugMessage = "TO_START_ATTACKING"
                    Attack(AttackObj)
                else
                    if MountUp() == false then
                        DebugMessage = "START_PATH"
                        if LOOT_ON_VENDOR_PATH == false then
                            VendorPath(false)
                        else
                            if Skinning() == false and Looting() == false then
                                VendorPath(false)
                            end
                        end
                    end
                end
            elseif AtStartAfterVendor then  -- 变量复位
                ResetVariables()
            else
                if Skinning() == false and Looting() == false then
                    DebugMessage = "NOT_SKIN/LOOT-ING"
                    if FindAttackableUnit() then
                        DebugMessage = "ATTACK_2"
                        Attack(AttackObj)
                    else
                        local castingID = Wow.UnitCastID("player")
                        if castingID ~= 0 and inCombat == false then -- Mage problem
                            DebugMessage = "PREVENTING_MAGE_CAST_INTERR"
                        else
                            if TargetIsFar and MOUNT_WHILE_GRINDING and Wow.IsIndoors() == false and Wow.IsMounted() == false and HasMount() then
                                if MountUp() then
                                    DebugMessage = "MOUNTING_TO_NEXT_TARGET"
                                    Wow.DebugPrint('Target is far away... Mounting!')
                                end
                            else
                                DebugMessage = "MOVEMENT_LAST"
                                PulseMovement()
                                PathEndCheck()
                            end
                        end
                    end
                else
                    DebugMessage = "LOOTING_SKINNING"
                    SetIDXToClosest(true, 10)
                end
            end
        end
    else
        if #AvoidNPCs > 0 then
            FindAttackableUnit() -- still need to avoid dangerous NPCs
        end
        DebugMessage = "VITALS_FAILED"
    end

    -- 卡住了
    if StuckTime > 90 or CombatTime > 120 then
        Wow.WriteFile("/Log/Status.txt", 'Bot is stuck at idx ' .. PathIdx, false)
        Wow.WriteFile("/Log/Terminate.txt", 'Stuck at idx: ' .. PathIdx, false)
        Wow.RunMacroText(".dc")
        Exit("Stuck")
    end
end

-- 插件命令
do
    SLASH_LYNX_START1 = "/lynx-start"
    SLASH_LYNX_STOP1 = "/lynx-stop"

    SlashCmdList["LYNX_START"] = function()
        Wow.DebugPrint("Lynx start!")
        Frame:SetScript("OnUpdate", DoBotStuff)
    end

    SlashCmdList["LYNX_STOP"] = function()
        Wow.DebugPrint("Lynx stop!")
        Frame:SetScript("OnUpdate", nil)
    end
end
